/**
 * @fileoverview added by tsickle
 * Generated from: document/document.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { from } from 'rxjs';
import { fromDocRef } from '../observable/fromRef';
import { map, observeOn } from 'rxjs/operators';
import { associateQuery } from '../firestore';
import { AngularFirestoreCollection } from '../collection/collection';
/**
 * AngularFirestoreDocument service
 *
 * This class creates a reference to a Firestore Document. A reference is provided in
 * in the constructor. The class is generic which gives you type safety for data update
 * methods and data streaming.
 *
 * This class uses Symbol.observable to transform into Observable using Observable.from().
 *
 * This class is rarely used directly and should be created from the AngularFirestore service.
 *
 * Example:
 *
 * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));
 * await fakeStock.set({ name: 'FAKE', price: 0.01 });
 * fakeStock.valueChanges().map(snap => {
 *   if(snap.exists) return snap.data();
 *   return null;
 * }).subscribe(value => console.log(value));
 * // OR! Transform using Observable.from() and the data is unwrapped for you
 * Observable.from(fakeStock).subscribe(value => console.log(value));
 * @template T
 */
export class AngularFirestoreDocument {
    /**
     * The constructor takes in a DocumentReference to provide wrapper methods
     * for data operations, data streaming, and Symbol.observable.
     * @param {?} ref
     * @param {?} afs
     */
    constructor(ref, afs) {
        this.ref = ref;
        this.afs = afs;
    }
    /**
     * Create or overwrite a single document.
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    set(data, options) {
        return this.ref.set(data, options);
    }
    /**
     * Update some fields of a document without overwriting the entire document.
     * @param {?} data
     * @return {?}
     */
    update(data) {
        return this.ref.update(data);
    }
    /**
     * Delete a document.
     * @return {?}
     */
    delete() {
        return this.ref.delete();
    }
    /**
     * Create a reference to a sub-collection given a path and an optional query
     * function.
     * @template R
     * @param {?} path
     * @param {?=} queryFn
     * @return {?}
     */
    collection(path, queryFn) {
        /** @type {?} */
        const collectionRef = (/** @type {?} */ (this.ref.collection(path)));
        const { ref, query } = associateQuery(collectionRef, queryFn);
        return new AngularFirestoreCollection(ref, query, this.afs);
    }
    /**
     * Listen to snapshot updates from the document.
     * @return {?}
     */
    snapshotChanges() {
        /** @type {?} */
        const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);
        return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);
    }
    /**
     * @template K
     * @param {?=} options
     * @return {?}
     */
    valueChanges(options = {}) {
        return this.snapshotChanges().pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ payload }) => options.idField ? (/** @type {?} */ (Object.assign(Object.assign({}, payload.data()), { [options.idField]: payload.id }))) : payload.data())));
    }
    /**
     * Retrieve the document once.
     * @param {?=} options
     * @return {?}
     */
    get(options) {
        return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));
    }
}
if (false) {
    /** @type {?} */
    AngularFirestoreDocument.prototype.ref;
    /**
     * @type {?}
     * @private
     */
    AngularFirestoreDocument.prototype.afs;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnQuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvYW5ndWxhcmZpcmUvYW5ndWxhcmZpcmUvc3JjL2ZpcmVzdG9yZS8iLCJzb3VyY2VzIjpbImRvY3VtZW50L2RvY3VtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLElBQUksRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUV4QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkQsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNoRCxPQUFPLEVBQW9CLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUNoRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJ0RSxNQUFNLE9BQU8sd0JBQXdCOzs7Ozs7O0lBTW5DLFlBQW1CLEdBQXlCLEVBQVUsR0FBcUI7UUFBeEQsUUFBRyxHQUFILEdBQUcsQ0FBc0I7UUFBVSxRQUFHLEdBQUgsR0FBRyxDQUFrQjtJQUFJLENBQUM7Ozs7Ozs7SUFLaEYsR0FBRyxDQUFDLElBQU8sRUFBRSxPQUFvQjtRQUMvQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNyQyxDQUFDOzs7Ozs7SUFLRCxNQUFNLENBQUMsSUFBZ0I7UUFDckIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDOzs7OztJQUtELE1BQU07UUFDSixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDM0IsQ0FBQzs7Ozs7Ozs7O0lBTUQsVUFBVSxDQUFtQixJQUFZLEVBQUUsT0FBaUI7O2NBQ3BELGFBQWEsR0FBRyxtQkFBQSxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBNkM7Y0FDdEYsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsY0FBYyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUM7UUFDN0QsT0FBTyxJQUFJLDBCQUEwQixDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlELENBQUM7Ozs7O0lBS0QsZUFBZTs7Y0FDUCxvQkFBb0IsR0FBRyxVQUFVLENBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUM7UUFDeEYsT0FBTyxvQkFBb0IsQ0FBQyxJQUFJLENBQzlCLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQ2hDLENBQUM7SUFDSixDQUFDOzs7Ozs7SUFVRCxZQUFZLENBQW1CLFVBQTJCLEVBQUU7UUFDMUQsT0FBTyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxDQUNoQyxHQUFHOzs7O1FBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FDbEIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsbURBQ2IsT0FBTyxDQUFDLElBQUksRUFBRSxHQUNkLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRSxHQUNULENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFDL0MsQ0FDRixDQUFDO0lBQ0osQ0FBQzs7Ozs7O0lBS0QsR0FBRyxDQUFDLE9BQXVDO1FBQ3pDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNyQyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQzdDLENBQUM7SUFDSixDQUFDO0NBQ0Y7OztJQXRFYSx1Q0FBZ0M7Ozs7O0lBQUUsdUNBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQWN0aW9uLCBEb2N1bWVudERhdGEsIERvY3VtZW50UmVmZXJlbmNlLCBEb2N1bWVudFNuYXBzaG90LCBRdWVyeUZuLCBTZXRPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBmcm9tRG9jUmVmIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9mcm9tUmVmJztcbmltcG9ydCB7IG1hcCwgb2JzZXJ2ZU9uIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZSwgYXNzb2NpYXRlUXVlcnkgfSBmcm9tICcuLi9maXJlc3RvcmUnO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb24gfSBmcm9tICcuLi9jb2xsZWN0aW9uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5cbi8qKlxuICogQW5ndWxhckZpcmVzdG9yZURvY3VtZW50IHNlcnZpY2VcbiAqXG4gKiBUaGlzIGNsYXNzIGNyZWF0ZXMgYSByZWZlcmVuY2UgdG8gYSBGaXJlc3RvcmUgRG9jdW1lbnQuIEEgcmVmZXJlbmNlIGlzIHByb3ZpZGVkIGluXG4gKiBpbiB0aGUgY29uc3RydWN0b3IuIFRoZSBjbGFzcyBpcyBnZW5lcmljIHdoaWNoIGdpdmVzIHlvdSB0eXBlIHNhZmV0eSBmb3IgZGF0YSB1cGRhdGVcbiAqIG1ldGhvZHMgYW5kIGRhdGEgc3RyZWFtaW5nLlxuICpcbiAqIFRoaXMgY2xhc3MgdXNlcyBTeW1ib2wub2JzZXJ2YWJsZSB0byB0cmFuc2Zvcm0gaW50byBPYnNlcnZhYmxlIHVzaW5nIE9ic2VydmFibGUuZnJvbSgpLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgcmFyZWx5IHVzZWQgZGlyZWN0bHkgYW5kIHNob3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIEFuZ3VsYXJGaXJlc3RvcmUgc2VydmljZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGNvbnN0IGZha2VTdG9jayA9IG5ldyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8U3RvY2s+KGRvYygnc3RvY2tzL0ZBS0UnKSk7XG4gKiBhd2FpdCBmYWtlU3RvY2suc2V0KHsgbmFtZTogJ0ZBS0UnLCBwcmljZTogMC4wMSB9KTtcbiAqIGZha2VTdG9jay52YWx1ZUNoYW5nZXMoKS5tYXAoc25hcCA9PiB7XG4gKiAgIGlmKHNuYXAuZXhpc3RzKSByZXR1cm4gc25hcC5kYXRhKCk7XG4gKiAgIHJldHVybiBudWxsO1xuICogfSkuc3Vic2NyaWJlKHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XG4gKiAvLyBPUiEgVHJhbnNmb3JtIHVzaW5nIE9ic2VydmFibGUuZnJvbSgpIGFuZCB0aGUgZGF0YSBpcyB1bndyYXBwZWQgZm9yIHlvdVxuICogT2JzZXJ2YWJsZS5mcm9tKGZha2VTdG9jaykuc3Vic2NyaWJlKHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VCA9IERvY3VtZW50RGF0YT4ge1xuXG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3IgdGFrZXMgaW4gYSBEb2N1bWVudFJlZmVyZW5jZSB0byBwcm92aWRlIHdyYXBwZXIgbWV0aG9kc1xuICAgKiBmb3IgZGF0YSBvcGVyYXRpb25zLCBkYXRhIHN0cmVhbWluZywgYW5kIFN5bWJvbC5vYnNlcnZhYmxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHJlZjogRG9jdW1lbnRSZWZlcmVuY2U8VD4sIHByaXZhdGUgYWZzOiBBbmd1bGFyRmlyZXN0b3JlKSB7IH1cblxuICAvKipcbiAgICogQ3JlYXRlIG9yIG92ZXJ3cml0ZSBhIHNpbmdsZSBkb2N1bWVudC5cbiAgICovXG4gIHNldChkYXRhOiBULCBvcHRpb25zPzogU2V0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlZi5zZXQoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHNvbWUgZmllbGRzIG9mIGEgZG9jdW1lbnQgd2l0aG91dCBvdmVyd3JpdGluZyB0aGUgZW50aXJlIGRvY3VtZW50LlxuICAgKi9cbiAgdXBkYXRlKGRhdGE6IFBhcnRpYWw8VD4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yZWYudXBkYXRlKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRvY3VtZW50LlxuICAgKi9cbiAgZGVsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJlZi5kZWxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZWZlcmVuY2UgdG8gYSBzdWItY29sbGVjdGlvbiBnaXZlbiBhIHBhdGggYW5kIGFuIG9wdGlvbmFsIHF1ZXJ5XG4gICAqIGZ1bmN0aW9uLlxuICAgKi9cbiAgY29sbGVjdGlvbjxSID0gRG9jdW1lbnREYXRhPihwYXRoOiBzdHJpbmcsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248Uj4ge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25SZWYgPSB0aGlzLnJlZi5jb2xsZWN0aW9uKHBhdGgpIGFzIGZpcmViYXNlLmZpcmVzdG9yZS5Db2xsZWN0aW9uUmVmZXJlbmNlPFI+O1xuICAgIGNvbnN0IHsgcmVmLCBxdWVyeSB9ID0gYXNzb2NpYXRlUXVlcnkoY29sbGVjdGlvblJlZiwgcXVlcnlGbik7XG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbihyZWYsIHF1ZXJ5LCB0aGlzLmFmcyk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIHNuYXBzaG90IHVwZGF0ZXMgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAqL1xuICBzbmFwc2hvdENoYW5nZXMoKTogT2JzZXJ2YWJsZTxBY3Rpb248RG9jdW1lbnRTbmFwc2hvdDxUPj4+IHtcbiAgICBjb25zdCBzY2hlZHVsZWRGcm9tRG9jUmVmJCA9IGZyb21Eb2NSZWY8VD4odGhpcy5yZWYsIHRoaXMuYWZzLnNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpO1xuICAgIHJldHVybiBzY2hlZHVsZWRGcm9tRG9jUmVmJC5waXBlKFxuICAgICAgdGhpcy5hZnMua2VlcFVuc3RhYmxlVW50aWxGaXJzdFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIHVud3JhcHBlZCBzbmFwc2hvdCB1cGRhdGVzIGZyb20gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBJZiB0aGUgYGlkRmllbGRgIG9wdGlvbiBpcyBwcm92aWRlZCwgZG9jdW1lbnQgSURzIGFyZSBpbmNsdWRlZCBhbmQgbWFwcGVkIHRvIHRoZVxuICAgKiBwcm92aWRlZCBgaWRGaWVsZGAgcHJvcGVydHkgbmFtZS5cbiAgICovXG4gIHZhbHVlQ2hhbmdlcyhvcHRpb25zPzogeyB9KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgdmFsdWVDaGFuZ2VzPEsgZXh0ZW5kcyBzdHJpbmc+KG9wdGlvbnM6IHsgaWRGaWVsZDogSyB9KTogT2JzZXJ2YWJsZTwoVCAmIHsgW1QgaW4gS106IHN0cmluZyB9KSB8IHVuZGVmaW5lZD47XG4gIHZhbHVlQ2hhbmdlczxLIGV4dGVuZHMgc3RyaW5nPihvcHRpb25zOiB7IGlkRmllbGQ/OiBLIH0gPSB7fSk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnNuYXBzaG90Q2hhbmdlcygpLnBpcGUoXG4gICAgICBtYXAoKHsgcGF5bG9hZCB9KSA9PlxuICAgICAgICBvcHRpb25zLmlkRmllbGQgPyB7XG4gICAgICAgICAgLi4ucGF5bG9hZC5kYXRhKCksXG4gICAgICAgICAgLi4ueyBbb3B0aW9ucy5pZEZpZWxkXTogcGF5bG9hZC5pZCB9XG4gICAgICAgIH0gYXMgVCAmIHsgW1QgaW4gS106IHN0cmluZyB9IDogcGF5bG9hZC5kYXRhKClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBkb2N1bWVudCBvbmNlLlxuICAgKi9cbiAgZ2V0KG9wdGlvbnM/OiBmaXJlYmFzZS5maXJlc3RvcmUuR2V0T3B0aW9ucykge1xuICAgIHJldHVybiBmcm9tKHRoaXMucmVmLmdldChvcHRpb25zKSkucGlwZShcbiAgICAgIG9ic2VydmVPbih0aGlzLmFmcy5zY2hlZHVsZXJzLmluc2lkZUFuZ3VsYXIpLFxuICAgICk7XG4gIH1cbn1cbiJdfQ==