/**
 * @fileoverview added by tsickle
 * Generated from: list/changes.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { fromRef } from '../observable/fromRef';
import { merge, of } from 'rxjs';
import { isNil } from '../utils';
import { distinctUntilChanged, scan, switchMap } from 'rxjs/operators';
/**
 * @template T
 * @param {?} ref
 * @param {?} events
 * @param {?=} scheduler
 * @return {?}
 */
export function listChanges(ref, events, scheduler) {
    return fromRef(ref, 'value', 'once', scheduler).pipe(switchMap((/**
     * @param {?} snapshotAction
     * @return {?}
     */
    snapshotAction => {
        /** @type {?} */
        const childEvent$ = [of(snapshotAction)];
        events.forEach((/**
         * @param {?} event
         * @return {?}
         */
        event => childEvent$.push(fromRef(ref, event, 'on', scheduler))));
        return merge(...childEvent$).pipe(scan(buildView, []));
    })), distinctUntilChanged());
}
/**
 * @template T
 * @param {?} changes
 * @param {?} key
 * @return {?}
 */
function positionFor(changes, key) {
    /** @type {?} */
    const len = changes.length;
    for (let i = 0; i < len; i++) {
        if (changes[i].payload.key === key) {
            return i;
        }
    }
    return -1;
}
/**
 * @template T
 * @param {?} changes
 * @param {?=} prevKey
 * @return {?}
 */
function positionAfter(changes, prevKey) {
    if (isNil(prevKey)) {
        return 0;
    }
    else {
        /** @type {?} */
        const i = positionFor(changes, prevKey);
        if (i === -1) {
            return changes.length;
        }
        else {
            return i + 1;
        }
    }
}
/**
 * @param {?} current
 * @param {?} action
 * @return {?}
 */
function buildView(current, action) {
    const { payload, prevKey, key } = action;
    /** @type {?} */
    const currentKeyPosition = positionFor(current, key);
    /** @type {?} */
    const afterPreviousKeyPosition = positionAfter(current, prevKey);
    switch (action.type) {
        case 'value':
            if (action.payload && action.payload.exists()) {
                /** @type {?} */
                let prevKey = null;
                action.payload.forEach((/**
                 * @param {?} payload
                 * @return {?}
                 */
                payload => {
                    /** @type {?} */
                    const action = { payload, type: 'value', prevKey, key: payload.key };
                    prevKey = payload.key;
                    current = [...current, action];
                    return false;
                }));
            }
            return current;
        case 'child_added':
            if (currentKeyPosition > -1) {
                // check that the previouskey is what we expect, else reorder
                /** @type {?} */
                const previous = current[currentKeyPosition - 1];
                if ((previous && previous.key || null) !== prevKey) {
                    current = current.filter((/**
                     * @param {?} x
                     * @return {?}
                     */
                    x => x.payload.key !== payload.key));
                    current.splice(afterPreviousKeyPosition, 0, action);
                }
            }
            else if (prevKey == null) {
                return [action, ...current];
            }
            else {
                current = current.slice();
                current.splice(afterPreviousKeyPosition, 0, action);
            }
            return current;
        case 'child_removed':
            return current.filter((/**
             * @param {?} x
             * @return {?}
             */
            x => x.payload.key !== payload.key));
        case 'child_changed':
            return current.map((/**
             * @param {?} x
             * @return {?}
             */
            x => x.payload.key === key ? action : x));
        case 'child_moved':
            if (currentKeyPosition > -1) {
                /** @type {?} */
                const data = current.splice(currentKeyPosition, 1)[0];
                current = current.slice();
                current.splice(afterPreviousKeyPosition, 0, data);
                return current;
            }
            return current;
        // default will also remove null results
        default:
            return current;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbmdlcy5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9hbmd1bGFyZmlyZS9hbmd1bGFyZmlyZS9zcmMvZGF0YWJhc2UvIiwic291cmNlcyI6WyJsaXN0L2NoYW5nZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDaEQsT0FBTyxFQUFFLEtBQUssRUFBYyxFQUFFLEVBQWlCLE1BQU0sTUFBTSxDQUFDO0FBRzVELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFakMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7QUFFdkUsTUFBTSxVQUFVLFdBQVcsQ0FBVSxHQUFrQixFQUFFLE1BQW9CLEVBQUUsU0FBeUI7SUFDdEcsT0FBTyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUNsRCxTQUFTOzs7O0lBQUMsY0FBYyxDQUFDLEVBQUU7O2NBQ25CLFdBQVcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsT0FBTzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBQyxDQUFDO1FBQ2hGLE9BQU8sS0FBSyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDLEVBQUMsRUFDRixvQkFBb0IsRUFBRSxDQUN2QixDQUFDO0FBQ0osQ0FBQzs7Ozs7OztBQUVELFNBQVMsV0FBVyxDQUFJLE9BQTRCLEVBQUUsR0FBRzs7VUFD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QUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLE9BQU8sQ0FBQyxHQUFHLEVBQUMsQ0FBQztRQUM1RCxLQUFLLGVBQWU7WUFDbEIsT0FBTyxPQUFPLENBQUMsR0FBRzs7OztZQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDO1FBQzlELEtBQUssYUFBYTtZQUNoQixJQUFJLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxFQUFFOztzQkFDckIsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxPQUFPLEdBQUcsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUMxQixPQUFPLENBQUMsTUFBTSxDQUFDLHdCQUF3QixFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbEQsT0FBTyxPQUFPLENBQUM7YUFDaEI7WUFDRCxPQUFPLE9BQU8sQ0FBQztRQUNqQix3Q0FBd0M7UUFDeEM7WUFDRSxPQUFPLE9BQU8sQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcm9tUmVmIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9mcm9tUmVmJztcbmltcG9ydCB7IG1lcmdlLCBPYnNlcnZhYmxlLCBvZiwgU2NoZWR1bGVyTGlrZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDaGlsZEV2ZW50LCBEYXRhYmFzZVF1ZXJ5LCBTbmFwc2hvdEFjdGlvbiB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgaXNOaWwgfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBzY2FuLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q2hhbmdlczxUID0gYW55PihyZWY6IERhdGFiYXNlUXVlcnksIGV2ZW50czogQ2hpbGRFdmVudFtdLCBzY2hlZHVsZXI/OiBTY2hlZHVsZXJMaWtlKTogT2JzZXJ2YWJsZTxTbmFwc2hvdEFjdGlvbjxUPltdPiB7XG4gIHJldHVybiBmcm9tUmVmKHJlZiwgJ3ZhbHVlJywgJ29uY2UnLCBzY2hlZHVsZXIpLnBpcGUoXG4gICAgc3dpdGNoTWFwKHNuYXBzaG90QWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkRXZlbnQkID0gW29mKHNuYXBzaG90QWN0aW9uKV07XG4gICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiBjaGlsZEV2ZW50JC5wdXNoKGZyb21SZWYocmVmLCBldmVudCwgJ29uJywgc2NoZWR1bGVyKSkpO1xuICAgICAgcmV0dXJuIG1lcmdlKC4uLmNoaWxkRXZlbnQkKS5waXBlKHNjYW4oYnVpbGRWaWV3LCBbXSkpO1xuICAgIH0pLFxuICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgKTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25Gb3I8VD4oY2hhbmdlczogU25hcHNob3RBY3Rpb248VD5bXSwga2V5KSB7XG4gIGNvbnN0IGxlbiA9IGNoYW5nZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNoYW5nZXNbaV0ucGF5bG9hZC5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25BZnRlcjxUPihjaGFuZ2VzOiBTbmFwc2hvdEFjdGlvbjxUPltdLCBwcmV2S2V5Pzogc3RyaW5nKSB7XG4gIGlmIChpc05pbChwcmV2S2V5KSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGkgPSBwb3NpdGlvbkZvcihjaGFuZ2VzLCBwcmV2S2V5KTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGkgKyAxO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFZpZXcoY3VycmVudCwgYWN0aW9uKSB7XG4gIGNvbnN0IHsgcGF5bG9hZCwgcHJldktleSwga2V5IH0gPSBhY3Rpb247XG4gIGNvbnN0IGN1cnJlbnRLZXlQb3NpdGlvbiA9IHBvc2l0aW9uRm9yKGN1cnJlbnQsIGtleSk7XG4gIGNvbnN0IGFmdGVyUHJldmlvdXNLZXlQb3NpdGlvbiA9IHBvc2l0aW9uQWZ0ZXIoY3VycmVudCwgcHJldktleSk7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICd2YWx1ZSc6XG4gICAgICBpZiAoYWN0aW9uLnBheWxvYWQgJiYgYWN0aW9uLnBheWxvYWQuZXhpc3RzKCkpIHtcbiAgICAgICAgbGV0IHByZXZLZXkgPSBudWxsO1xuICAgICAgICBhY3Rpb24ucGF5bG9hZC5mb3JFYWNoKHBheWxvYWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHsgcGF5bG9hZCwgdHlwZTogJ3ZhbHVlJywgcHJldktleSwga2V5OiBwYXlsb2FkLmtleSB9O1xuICAgICAgICAgIHByZXZLZXkgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgICBjdXJyZW50ID0gWy4uLmN1cnJlbnQsIGFjdGlvbl07XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIGNhc2UgJ2NoaWxkX2FkZGVkJzpcbiAgICAgIGlmIChjdXJyZW50S2V5UG9zaXRpb24gPiAtMSkge1xuICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBwcmV2aW91c2tleSBpcyB3aGF0IHdlIGV4cGVjdCwgZWxzZSByZW9yZGVyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gY3VycmVudFtjdXJyZW50S2V5UG9zaXRpb24gLSAxXTtcbiAgICAgICAgaWYgKChwcmV2aW91cyAmJiBwcmV2aW91cy5rZXkgfHwgbnVsbCkgIT09IHByZXZLZXkpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5maWx0ZXIoeCA9PiB4LnBheWxvYWQua2V5ICE9PSBwYXlsb2FkLmtleSk7XG4gICAgICAgICAgY3VycmVudC5zcGxpY2UoYWZ0ZXJQcmV2aW91c0tleVBvc2l0aW9uLCAwLCBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZLZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2FjdGlvbiwgLi4uY3VycmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zbGljZSgpO1xuICAgICAgICBjdXJyZW50LnNwbGljZShhZnRlclByZXZpb3VzS2V5UG9zaXRpb24sIDAsIGFjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICBjYXNlICdjaGlsZF9yZW1vdmVkJzpcbiAgICAgIHJldHVybiBjdXJyZW50LmZpbHRlcih4ID0+IHgucGF5bG9hZC5rZXkgIT09IHBheWxvYWQua2V5KTtcbiAgICBjYXNlICdjaGlsZF9jaGFuZ2VkJzpcbiAgICAgIHJldHVybiBjdXJyZW50Lm1hcCh4ID0+IHgucGF5bG9hZC5rZXkgPT09IGtleSA/IGFjdGlvbiA6IHgpO1xuICAgIGNhc2UgJ2NoaWxkX21vdmVkJzpcbiAgICAgIGlmIChjdXJyZW50S2V5UG9zaXRpb24gPiAtMSkge1xuICAgICAgICBjb25zdCBkYXRhID0gY3VycmVudC5zcGxpY2UoY3VycmVudEtleVBvc2l0aW9uLCAxKVswXTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoYWZ0ZXJQcmV2aW91c0tleVBvc2l0aW9uLCAwLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICAvLyBkZWZhdWx0IHdpbGwgYWxzbyByZW1vdmUgbnVsbCByZXN1bHRzXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICB9XG59XG4iXX0=