/**
 * @fileoverview added by tsickle
 * Generated from: list/audit-trail.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { stateChanges } from './state-changes';
import { fromRef } from '../observable/fromRef';
import { map, scan, skipWhile, withLatestFrom } from 'rxjs/operators';
/**
 * @template T
 * @param {?} query
 * @param {?=} events
 * @param {?=} scheduler
 * @return {?}
 */
export function auditTrail(query, events, scheduler) {
    /** @type {?} */
    const auditTrail$ = stateChanges(query, events)
        .pipe(scan((/**
     * @param {?} current
     * @param {?} action
     * @return {?}
     */
    (current, action) => [...current, action]), []));
    return waitForLoaded(query, auditTrail$, scheduler);
}
/**
 * @record
 */
function LoadedMetadata() { }
if (false) {
    /** @type {?} */
    LoadedMetadata.prototype.data;
    /** @type {?} */
    LoadedMetadata.prototype.lastKeyToLoad;
}
/**
 * @template T
 * @param {?} query
 * @param {?=} scheduler
 * @return {?}
 */
function loadedData(query, scheduler) {
    // Create an observable of loaded values to retrieve the
    // known dataset. This will allow us to know what key to
    // emit the "whole" array at when listening for child events.
    return fromRef(query, 'value', 'on', scheduler)
        .pipe(map((/**
     * @param {?} data
     * @return {?}
     */
    data => {
        // Store the last key in the data set
        /** @type {?} */
        let lastKeyToLoad;
        // Loop through loaded dataset to find the last key
        data.payload.forEach((/**
         * @param {?} child
         * @return {?}
         */
        child => {
            lastKeyToLoad = child.key;
            return false;
        }));
        // return data set and the current last key loaded
        return { data, lastKeyToLoad };
    })));
}
/**
 * @template T
 * @param {?} query
 * @param {?} action$
 * @param {?=} scheduler
 * @return {?}
 */
function waitForLoaded(query, action$, scheduler) {
    /** @type {?} */
    const loaded$ = loadedData(query, scheduler);
    return loaded$
        .pipe(withLatestFrom(action$), 
    // Get the latest values from the "loaded" and "child" datasets
    // We can use both datasets to form an array of the latest values.
    map((/**
     * @param {?} __0
     * @return {?}
     */
    ([loaded, actions]) => {
        // Store the last key in the data set
        /** @type {?} */
        const lastKeyToLoad = loaded.lastKeyToLoad;
        // Store all child keys loaded at this point
        /** @type {?} */
        const loadedKeys = actions.map((/**
         * @param {?} snap
         * @return {?}
         */
        snap => snap.key));
        return { actions, lastKeyToLoad, loadedKeys };
    })), 
    // This is the magical part, only emit when the last load key
    // in the dataset has been loaded by a child event. At this point
    // we can assume the dataset is "whole".
    skipWhile((/**
     * @param {?} meta
     * @return {?}
     */
    meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1)), 
    // Pluck off the meta data because the user only cares
    // to iterate through the snapshots
    map((/**
     * @param {?} meta
     * @return {?}
     */
    meta => meta.actions)));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVkaXQtdHJhaWwuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvcnVubmVyL3dvcmsvYW5ndWxhcmZpcmUvYW5ndWxhcmZpcmUvc3JjL2RhdGFiYXNlLyIsInNvdXJjZXMiOlsibGlzdC9hdWRpdC10cmFpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUvQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFaEQsT0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7OztBQUV0RSxNQUFNLFVBQVUsVUFBVSxDQUFJLEtBQW9CLEVBQUUsTUFBcUIsRUFBRSxTQUF5Qjs7VUFDNUYsV0FBVyxHQUFHLFlBQVksQ0FBSSxLQUFLLEVBQUUsTUFBTSxDQUFDO1NBQy9DLElBQUksQ0FDSCxJQUFJOzs7OztJQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLE9BQU8sRUFBRSxNQUFNLENBQUMsR0FBRSxFQUFFLENBQUMsQ0FDcEQ7SUFDSCxPQUFPLGFBQWEsQ0FBSSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3pELENBQUM7Ozs7QUFFRCw2QkFHQzs7O0lBRkMsOEJBQXNDOztJQUN0Qyx1Q0FBbUI7Ozs7Ozs7O0FBR3JCLFNBQVMsVUFBVSxDQUFJLEtBQW9CLEVBQUUsU0FBeUI7SUFDcEUsd0RBQXdEO0lBQ3hELHdEQUF3RDtJQUN4RCw2REFBNkQ7SUFDN0QsT0FBTyxPQUFPLENBQUksS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsU0FBUyxDQUFDO1NBQ2pELElBQUksQ0FDSCxHQUFHOzs7O0lBQUMsSUFBSSxDQUFDLEVBQUU7OztZQUVMLGFBQWE7UUFDakIsbURBQW1EO1FBQ25ELElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzNCLGFBQWEsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQUMsT0FBTyxLQUFLLENBQUM7UUFDMUMsQ0FBQyxFQUFDLENBQUM7UUFDSCxrREFBa0Q7UUFDbEQsT0FBTyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsQ0FBQztJQUNqQyxDQUFDLEVBQUMsQ0FDSCxDQUFDO0FBQ0osQ0FBQzs7Ozs7Ozs7QUFFRCxTQUFTLGFBQWEsQ0FBSSxLQUFvQixFQUFFLE9BQXdDLEVBQUUsU0FBeUI7O1VBQzNHLE9BQU8sR0FBRyxVQUFVLENBQUksS0FBSyxFQUFFLFNBQVMsQ0FBQztJQUMvQyxPQUFPLE9BQU87U0FDWCxJQUFJLENBQ0gsY0FBYyxDQUFDLE9BQU8sQ0FBQztJQUN2QiwrREFBK0Q7SUFDL0Qsa0VBQWtFO0lBQ2xFLEdBQUc7Ozs7SUFBQyxDQUFDLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUU7OztjQUVsQixhQUFhLEdBQUcsTUFBTSxDQUFDLGFBQWE7OztjQUVwQyxVQUFVLEdBQUcsT0FBTyxDQUFDLEdBQUc7Ozs7UUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUM7UUFDaEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsVUFBVSxFQUFFLENBQUM7SUFDaEQsQ0FBQyxFQUFDO0lBQ0YsNkRBQTZEO0lBQzdELGlFQUFpRTtJQUNqRSx3Q0FBd0M7SUFDeEMsU0FBUzs7OztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDO0lBQ3JFLHNEQUFzRDtJQUN0RCxtQ0FBbUM7SUFDbkMsR0FBRzs7OztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBQyxDQUMxQixDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFuZ3VsYXJGaXJlQWN0aW9uLCBDaGlsZEV2ZW50LCBEYXRhYmFzZVF1ZXJ5LCBEYXRhU25hcHNob3QsIFNuYXBzaG90QWN0aW9uIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBzdGF0ZUNoYW5nZXMgfSBmcm9tICcuL3N0YXRlLWNoYW5nZXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU2NoZWR1bGVyTGlrZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZnJvbVJlZiB9IGZyb20gJy4uL29ic2VydmFibGUvZnJvbVJlZic7XG5cbmltcG9ydCB7IG1hcCwgc2Nhbiwgc2tpcFdoaWxlLCB3aXRoTGF0ZXN0RnJvbSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGF1ZGl0VHJhaWw8VD4ocXVlcnk6IERhdGFiYXNlUXVlcnksIGV2ZW50cz86IENoaWxkRXZlbnRbXSwgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZSk6IE9ic2VydmFibGU8U25hcHNob3RBY3Rpb248VD5bXT4ge1xuICBjb25zdCBhdWRpdFRyYWlsJCA9IHN0YXRlQ2hhbmdlczxUPihxdWVyeSwgZXZlbnRzKVxuICAgIC5waXBlKFxuICAgICAgc2NhbigoY3VycmVudCwgYWN0aW9uKSA9PiBbLi4uY3VycmVudCwgYWN0aW9uXSwgW10pXG4gICAgKTtcbiAgcmV0dXJuIHdhaXRGb3JMb2FkZWQ8VD4ocXVlcnksIGF1ZGl0VHJhaWwkLCBzY2hlZHVsZXIpO1xufVxuXG5pbnRlcmZhY2UgTG9hZGVkTWV0YWRhdGEge1xuICBkYXRhOiBBbmd1bGFyRmlyZUFjdGlvbjxEYXRhU25hcHNob3Q+O1xuICBsYXN0S2V5VG9Mb2FkOiBhbnk7XG59XG5cbmZ1bmN0aW9uIGxvYWRlZERhdGE8VD4ocXVlcnk6IERhdGFiYXNlUXVlcnksIHNjaGVkdWxlcj86IFNjaGVkdWxlckxpa2UpOiBPYnNlcnZhYmxlPExvYWRlZE1ldGFkYXRhPiB7XG4gIC8vIENyZWF0ZSBhbiBvYnNlcnZhYmxlIG9mIGxvYWRlZCB2YWx1ZXMgdG8gcmV0cmlldmUgdGhlXG4gIC8vIGtub3duIGRhdGFzZXQuIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBrbm93IHdoYXQga2V5IHRvXG4gIC8vIGVtaXQgdGhlIFwid2hvbGVcIiBhcnJheSBhdCB3aGVuIGxpc3RlbmluZyBmb3IgY2hpbGQgZXZlbnRzLlxuICByZXR1cm4gZnJvbVJlZjxUPihxdWVyeSwgJ3ZhbHVlJywgJ29uJywgc2NoZWR1bGVyKVxuICAucGlwZShcbiAgICBtYXAoZGF0YSA9PiB7XG4gICAgICAvLyBTdG9yZSB0aGUgbGFzdCBrZXkgaW4gdGhlIGRhdGEgc2V0XG4gICAgICBsZXQgbGFzdEtleVRvTG9hZDtcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBsb2FkZWQgZGF0YXNldCB0byBmaW5kIHRoZSBsYXN0IGtleVxuICAgICAgZGF0YS5wYXlsb2FkLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBsYXN0S2V5VG9Mb2FkID0gY2hpbGQua2V5OyByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIC8vIHJldHVybiBkYXRhIHNldCBhbmQgdGhlIGN1cnJlbnQgbGFzdCBrZXkgbG9hZGVkXG4gICAgICByZXR1cm4geyBkYXRhLCBsYXN0S2V5VG9Mb2FkIH07XG4gICAgfSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gd2FpdEZvckxvYWRlZDxUPihxdWVyeTogRGF0YWJhc2VRdWVyeSwgYWN0aW9uJDogT2JzZXJ2YWJsZTxTbmFwc2hvdEFjdGlvbjxUPltdPiwgc2NoZWR1bGVyPzogU2NoZWR1bGVyTGlrZSkge1xuICBjb25zdCBsb2FkZWQkID0gbG9hZGVkRGF0YTxUPihxdWVyeSwgc2NoZWR1bGVyKTtcbiAgcmV0dXJuIGxvYWRlZCRcbiAgICAucGlwZShcbiAgICAgIHdpdGhMYXRlc3RGcm9tKGFjdGlvbiQpLFxuICAgICAgLy8gR2V0IHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIFwibG9hZGVkXCIgYW5kIFwiY2hpbGRcIiBkYXRhc2V0c1xuICAgICAgLy8gV2UgY2FuIHVzZSBib3RoIGRhdGFzZXRzIHRvIGZvcm0gYW4gYXJyYXkgb2YgdGhlIGxhdGVzdCB2YWx1ZXMuXG4gICAgICBtYXAoKFtsb2FkZWQsIGFjdGlvbnNdKSA9PiB7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBsYXN0IGtleSBpbiB0aGUgZGF0YSBzZXRcbiAgICAgICAgY29uc3QgbGFzdEtleVRvTG9hZCA9IGxvYWRlZC5sYXN0S2V5VG9Mb2FkO1xuICAgICAgICAvLyBTdG9yZSBhbGwgY2hpbGQga2V5cyBsb2FkZWQgYXQgdGhpcyBwb2ludFxuICAgICAgICBjb25zdCBsb2FkZWRLZXlzID0gYWN0aW9ucy5tYXAoc25hcCA9PiBzbmFwLmtleSk7XG4gICAgICAgIHJldHVybiB7IGFjdGlvbnMsIGxhc3RLZXlUb0xvYWQsIGxvYWRlZEtleXMgfTtcbiAgICAgIH0pLFxuICAgICAgLy8gVGhpcyBpcyB0aGUgbWFnaWNhbCBwYXJ0LCBvbmx5IGVtaXQgd2hlbiB0aGUgbGFzdCBsb2FkIGtleVxuICAgICAgLy8gaW4gdGhlIGRhdGFzZXQgaGFzIGJlZW4gbG9hZGVkIGJ5IGEgY2hpbGQgZXZlbnQuIEF0IHRoaXMgcG9pbnRcbiAgICAgIC8vIHdlIGNhbiBhc3N1bWUgdGhlIGRhdGFzZXQgaXMgXCJ3aG9sZVwiLlxuICAgICAgc2tpcFdoaWxlKG1ldGEgPT4gbWV0YS5sb2FkZWRLZXlzLmluZGV4T2YobWV0YS5sYXN0S2V5VG9Mb2FkKSA9PT0gLTEpLFxuICAgICAgLy8gUGx1Y2sgb2ZmIHRoZSBtZXRhIGRhdGEgYmVjYXVzZSB0aGUgdXNlciBvbmx5IGNhcmVzXG4gICAgICAvLyB0byBpdGVyYXRlIHRocm91Z2ggdGhlIHNuYXBzaG90c1xuICAgICAgbWFwKG1ldGEgPT4gbWV0YS5hY3Rpb25zKVxuICAgICk7XG59XG4iXX0=