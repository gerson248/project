/**
 * @fileoverview added by tsickle
 * Generated from: angularfire2.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { asyncScheduler, queueScheduler } from 'rxjs';
import { observeOn, subscribeOn, tap } from 'rxjs/operators';
/**
 * @return {?}
 */
function noop() {
}
/**
 * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.
 */
// tslint:disable-next-line:class-name
export class ɵZoneScheduler {
    /**
     * @param {?} zone
     * @param {?=} delegate
     */
    constructor(zone, delegate = queueScheduler) {
        this.zone = zone;
        this.delegate = delegate;
    }
    /**
     * @return {?}
     */
    now() {
        return this.delegate.now();
    }
    /**
     * @param {?} work
     * @param {?=} delay
     * @param {?=} state
     * @return {?}
     */
    schedule(work, delay, state) {
        /** @type {?} */
        const targetZone = this.zone;
        // Wrap the specified work function to make sure that if nested scheduling takes place the
        // work is executed in the correct zone
        /** @type {?} */
        const workInZone = (/**
         * @this {?}
         * @param {?} state
         * @return {?}
         */
        function (state) {
            targetZone.runGuarded((/**
             * @return {?}
             */
            () => {
                work.apply(this, [state]);
            }));
        });
        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done
        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that
        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.
        return this.delegate.schedule(workInZone, delay, state);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.delegate;
}
// tslint:disable-next-line:class-name
/**
 * @template T
 */
export class ɵBlockUntilFirstOperator {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.task = null;
    }
    /**
     * @param {?} subscriber
     * @param {?} source
     * @return {?}
     */
    call(subscriber, source) {
        /** @type {?} */
        const unscheduleTask = this.unscheduleTask.bind(this);
        this.task = this.zone.run((/**
         * @return {?}
         */
        () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));
        return source.pipe(tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })).subscribe(subscriber).add(unscheduleTask);
    }
    /**
     * @private
     * @return {?}
     */
    unscheduleTask() {
        // maybe this is a race condition, invoke in a timeout
        // hold for 10ms while I try to figure out what is going on
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.task != null && this.task.state === 'scheduled') {
                this.task.invoke();
                this.task = null;
            }
        }), 10);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.task;
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.zone;
}
// tslint:disable-next-line:class-name
export class ɵAngularFireSchedulers {
    /**
     * @param {?} ngZone
     */
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.outsideAngular = ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current)));
        this.insideAngular = ngZone.run((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current, asyncScheduler)));
    }
}
if (false) {
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.outsideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.insideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.ngZone;
}
/**
 * Operator to block the zone until the first value has been emitted or the observable
 * has completed/errored. This is used to make sure that universal waits until the first
 * value from firebase but doesn't block the zone forever since the firebase subscription
 * is still alive.
 * @param {?} schedulers
 * @return {?}
 */
export function ɵkeepUnstableUntilFirstFactory(schedulers) {
    return (/**
     * @template T
     * @param {?} obs$
     * @return {?}
     */
    function keepUnstableUntilFirst(obs$) {
        obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));
        return obs$.pipe(
        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)
        subscribeOn(schedulers.outsideAngular), 
        // Run operators inside the angular zone (e.g. side effects via tap())
        observeOn(schedulers.insideAngular)
        // INVESTIGATE https://github.com/angular/angularfire/pull/2315
        // share()
        );
    });
}
// DEBUG quick debugger function for inline logging that typescript doesn't complain about
//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a
//       verbose mode for AngularFire in a future release that uses something like this in multiple places
//       usage: () => log('something') || returnValue
// const log = (...args: any[]): false => { console.log(...args); return false }
// The problem here are things like ngOnDestroy are missing, then triggering the service
// rather than dig too far; I'm capturing these as I go.
/** @type {?} */
const noopFunctions = ['ngOnDestroy'];
// INVESTIGATE should we make the Proxy revokable and do some cleanup?
//             right now it's fairly simple but I'm sure this will grow in complexity
/** @type {?} */
export const ɵlazySDKProxy = (/**
 * @param {?} klass
 * @param {?} observable
 * @param {?} zone
 * @param {?=} options
 * @return {?}
 */
(klass, observable, zone, options = {}) => {
    return new Proxy(klass, {
        get: (/**
         * @param {?} _
         * @param {?} name
         * @return {?}
         */
        (_, name) => zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            var _a;
            if (klass[name]) {
                if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {
                    options.spy.get(name, klass[name]);
                }
                return klass[name];
            }
            if (noopFunctions.indexOf(name) > -1) {
                return (/**
                 * @return {?}
                 */
                () => {
                });
            }
            /** @type {?} */
            const promise = observable.toPromise().then((/**
             * @param {?} mod
             * @return {?}
             */
            mod => {
                /** @type {?} */
                const ret = mod && mod[name];
                // TODO move to proper type guards
                if (typeof ret === 'function') {
                    return ret.bind(mod);
                }
                else if (ret && ret.then) {
                    return ret.then((/**
                     * @param {?} res
                     * @return {?}
                     */
                    (res) => zone.run((/**
                     * @return {?}
                     */
                    () => res))));
                }
                else {
                    return zone.run((/**
                     * @return {?}
                     */
                    () => ret));
                }
            }));
            // recurse the proxy
            return new Proxy((/**
             * @return {?}
             */
            () => { }), {
                get: (/**
                 * @param {?} _
                 * @param {?} name
                 * @return {?}
                 */
                (_, name) => promise[name]),
                // TODO handle callbacks as transparently as I can
                apply: (/**
                 * @param {?} self
                 * @param {?} _
                 * @param {?} args
                 * @return {?}
                 */
                (self, _, args) => promise.then((/**
                 * @param {?} it
                 * @return {?}
                 */
                it => {
                    var _a;
                    /** @type {?} */
                    const res = it && it(...args);
                    if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {
                        options.spy.apply(name, args, res);
                    }
                    return res;
                })))
            });
        })))
    });
});
/** @type {?} */
export const ɵapplyMixins = (/**
 * @param {?} derivedCtor
 * @param {?} constructors
 * @return {?}
 */
(derivedCtor, constructors) => {
    constructors.forEach((/**
     * @param {?} baseCtor
     * @return {?}
     */
    (baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));
        }));
    }));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcmZpcmUyLmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3J1bm5lci93b3JrL2FuZ3VsYXJmaXJlL2FuZ3VsYXJmaXJlL3NyYy9jb3JlLyIsInNvdXJjZXMiOlsiYW5ndWxhcmZpcmUyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUNMLGNBQWMsRUFHZCxjQUFjLEVBTWYsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUU3RCxTQUFTLElBQUk7QUFDYixDQUFDOzs7OztBQU1ELE1BQU0sT0FBTyxjQUFjOzs7OztJQUN6QixZQUFvQixJQUFTLEVBQVUsV0FBZ0IsY0FBYztRQUFqRCxTQUFJLEdBQUosSUFBSSxDQUFLO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBc0I7SUFDckUsQ0FBQzs7OztJQUVELEdBQUc7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQzs7Ozs7OztJQUVELFFBQVEsQ0FBQyxJQUF1RCxFQUFFLEtBQWMsRUFBRSxLQUFXOztjQUNyRixVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUk7Ozs7Y0FHdEIsVUFBVTs7Ozs7UUFBRyxVQUFxQyxLQUFVO1lBQ2hFLFVBQVUsQ0FBQyxVQUFVOzs7WUFBQyxHQUFHLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM1QixDQUFDLEVBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQTtRQUVELHNHQUFzRztRQUN0RyxpR0FBaUc7UUFDakcsK0dBQStHO1FBQy9HLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxRCxDQUFDO0NBQ0Y7Ozs7OztJQXRCYSw4QkFBaUI7Ozs7O0lB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QUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBhc3luY1NjaGVkdWxlcixcbiAgT2JzZXJ2YWJsZSxcbiAgT3BlcmF0b3IsXG4gIHF1ZXVlU2NoZWR1bGVyLFxuICBTY2hlZHVsZXJBY3Rpb24sXG4gIFNjaGVkdWxlckxpa2UsXG4gIFN1YnNjcmliZXIsXG4gIFN1YnNjcmlwdGlvbixcbiAgVGVhcmRvd25Mb2dpY1xufSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG9ic2VydmVPbiwgc3Vic2NyaWJlT24sIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgdGFza3Mgc28gdGhhdCB0aGV5IGFyZSBpbnZva2VkIGluc2lkZSB0aGUgWm9uZSB0aGF0IGlzIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjbGFzcy1uYW1lXG5leHBvcnQgY2xhc3MgybVab25lU2NoZWR1bGVyIGltcGxlbWVudHMgU2NoZWR1bGVyTGlrZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgem9uZTogYW55LCBwcml2YXRlIGRlbGVnYXRlOiBhbnkgPSBxdWV1ZVNjaGVkdWxlcikge1xuICB9XG5cbiAgbm93KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLm5vdygpO1xuICB9XG5cbiAgc2NoZWR1bGUod29yazogKHRoaXM6IFNjaGVkdWxlckFjdGlvbjxhbnk+LCBzdGF0ZT86IGFueSkgPT4gdm9pZCwgZGVsYXk/OiBudW1iZXIsIHN0YXRlPzogYW55KTogU3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdCB0YXJnZXRab25lID0gdGhpcy56b25lO1xuICAgIC8vIFdyYXAgdGhlIHNwZWNpZmllZCB3b3JrIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIG5lc3RlZCBzY2hlZHVsaW5nIHRha2VzIHBsYWNlIHRoZVxuICAgIC8vIHdvcmsgaXMgZXhlY3V0ZWQgaW4gdGhlIGNvcnJlY3Qgem9uZVxuICAgIGNvbnN0IHdvcmtJblpvbmUgPSBmdW5jdGlvbih0aGlzOiBTY2hlZHVsZXJBY3Rpb248YW55Piwgc3RhdGU6IGFueSkge1xuICAgICAgdGFyZ2V0Wm9uZS5ydW5HdWFyZGVkKCgpID0+IHtcbiAgICAgICAgd29yay5hcHBseSh0aGlzLCBbc3RhdGVdKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBTY2hlZHVsaW5nIGl0c2VsZiBuZWVkcyB0byBiZSBydW4gaW4gem9uZSB0byBlbnN1cmUgc2V0SW50ZXJ2YWwgY2FsbHMgZm9yIGFzeW5jIHNjaGVkdWxpbmcgYXJlIGRvbmVcbiAgICAvLyBpbnNpZGUgdGhlIGNvcnJlY3Qgem9uZS4gVGhpcyBzY2hlZHVsZXIgbmVlZHMgdG8gc2NoZWR1bGUgYXN5bmNocm9ub3VzbHkgYWx3YXlzIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gZmlyZWJhc2UgZW1pc3Npb25zIGFyZSBuZXZlciBzeW5jaHJvbm91cy4gU3BlY2lmeWluZyBhIGRlbGF5IGNhdXNlcyBpc3N1ZXMgd2l0aCB0aGUgcXVldWVTY2hlZHVsZXIgZGVsZWdhdGUuXG4gICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuc2NoZWR1bGUod29ya0luWm9uZSwgZGVsYXksIHN0YXRlKTtcbiAgfVxufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y2xhc3MtbmFtZVxuZXhwb3J0IGNsYXNzIMm1QmxvY2tVbnRpbEZpcnN0T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIHByaXZhdGUgdGFzazogTWFjcm9UYXNrIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBhbnkpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgY29uc3QgdW5zY2hlZHVsZVRhc2sgPSB0aGlzLnVuc2NoZWR1bGVUYXNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YXNrID0gdGhpcy56b25lLnJ1bigoKSA9PiBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2soJ2ZpcmViYXNlWm9uZUJsb2NrJywgbm9vcCwge30sIG5vb3AsIG5vb3ApKTtcblxuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIHRhcCh7IG5leHQ6IHVuc2NoZWR1bGVUYXNrLCBjb21wbGV0ZTogdW5zY2hlZHVsZVRhc2ssIGVycm9yOiB1bnNjaGVkdWxlVGFzayB9KVxuICAgICkuc3Vic2NyaWJlKHN1YnNjcmliZXIpLmFkZCh1bnNjaGVkdWxlVGFzayk7XG4gIH1cblxuICBwcml2YXRlIHVuc2NoZWR1bGVUYXNrKCkge1xuICAgIC8vIG1heWJlIHRoaXMgaXMgYSByYWNlIGNvbmRpdGlvbiwgaW52b2tlIGluIGEgdGltZW91dFxuICAgIC8vIGhvbGQgZm9yIDEwbXMgd2hpbGUgSSB0cnkgdG8gZmlndXJlIG91dCB3aGF0IGlzIGdvaW5nIG9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy50YXNrICE9IG51bGwgJiYgdGhpcy50YXNrLnN0YXRlID09PSAnc2NoZWR1bGVkJykge1xuICAgICAgICB0aGlzLnRhc2suaW52b2tlKCk7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICB9XG4gICAgfSwgMTApO1xuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpjbGFzcy1uYW1lXG5leHBvcnQgY2xhc3MgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMge1xuICBwdWJsaWMgcmVhZG9ubHkgb3V0c2lkZUFuZ3VsYXI6IMm1Wm9uZVNjaGVkdWxlcjtcbiAgcHVibGljIHJlYWRvbmx5IGluc2lkZUFuZ3VsYXI6IMm1Wm9uZVNjaGVkdWxlcjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmdab25lOiBOZ1pvbmUpIHtcbiAgICB0aGlzLm91dHNpZGVBbmd1bGFyID0gbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IG5ldyDJtVpvbmVTY2hlZHVsZXIoWm9uZS5jdXJyZW50KSk7XG4gICAgdGhpcy5pbnNpZGVBbmd1bGFyID0gbmdab25lLnJ1bigoKSA9PiBuZXcgybVab25lU2NoZWR1bGVyKFpvbmUuY3VycmVudCwgYXN5bmNTY2hlZHVsZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wZXJhdG9yIHRvIGJsb2NrIHRoZSB6b25lIHVudGlsIHRoZSBmaXJzdCB2YWx1ZSBoYXMgYmVlbiBlbWl0dGVkIG9yIHRoZSBvYnNlcnZhYmxlXG4gKiBoYXMgY29tcGxldGVkL2Vycm9yZWQuIFRoaXMgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhhdCB1bml2ZXJzYWwgd2FpdHMgdW50aWwgdGhlIGZpcnN0XG4gKiB2YWx1ZSBmcm9tIGZpcmViYXNlIGJ1dCBkb2Vzbid0IGJsb2NrIHRoZSB6b25lIGZvcmV2ZXIgc2luY2UgdGhlIGZpcmViYXNlIHN1YnNjcmlwdGlvblxuICogaXMgc3RpbGwgYWxpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KHNjaGVkdWxlcnM6IMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZWVwVW5zdGFibGVVbnRpbEZpcnN0PFQ+KG9icyQ6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBvYnMkID0gb2JzJC5saWZ0KFxuICAgICAgbmV3IMm1QmxvY2tVbnRpbEZpcnN0T3BlcmF0b3Ioc2NoZWR1bGVycy5uZ1pvbmUpXG4gICAgKTtcblxuICAgIHJldHVybiBvYnMkLnBpcGUoXG4gICAgICAvLyBSdW4gdGhlIHN1YnNjcmliZSBib2R5IG91dHNpZGUgb2YgQW5ndWxhciAoZS5nLiBjYWxsaW5nIEZpcmViYXNlIFNESyB0byBhZGQgYSBsaXN0ZW5lciB0byBhIGNoYW5nZSBldmVudClcbiAgICAgIHN1YnNjcmliZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgLy8gUnVuIG9wZXJhdG9ycyBpbnNpZGUgdGhlIGFuZ3VsYXIgem9uZSAoZS5nLiBzaWRlIGVmZmVjdHMgdmlhIHRhcCgpKVxuICAgICAgb2JzZXJ2ZU9uKHNjaGVkdWxlcnMuaW5zaWRlQW5ndWxhcilcbiAgICAgIC8vIElOVkVTVElHQVRFIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXJmaXJlL3B1bGwvMjMxNVxuICAgICAgLy8gc2hhcmUoKVxuICAgICk7XG4gIH07XG59XG5cbi8vIHRzbGludDpkaXNhYmxlOmJhbi10eXBlc1xudHlwZSBGdW5jdGlvblByb3BlcnR5TmFtZXM8VD4gPSB7IFtLIGluIGtleW9mIFRdOiBUW0tdIGV4dGVuZHMgRnVuY3Rpb24gPyBLIDogbmV2ZXIgfVtrZXlvZiBUXTtcbnR5cGUgUHJvbWlzZVJldHVybmluZ0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHtcbiAgW0sgaW4gRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogUmV0dXJuVHlwZTxUW0tdPiBleHRlbmRzIFByb21pc2U8YW55PiA/IEsgOiBuZXZlclxufVtGdW5jdGlvblByb3BlcnR5TmFtZXM8VD5dO1xudHlwZSBOb25Qcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+ID0ge1xuICBbSyBpbiBGdW5jdGlvblByb3BlcnR5TmFtZXM8VD5dOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgUHJvbWlzZTxhbnk+ID8gbmV2ZXIgOiBLXG59W0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl07XG50eXBlIE5vbkZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gZXh0ZW5kcyBGdW5jdGlvbiA/IG5ldmVyIDogSyB9W2tleW9mIFRdO1xuLy8gdHNsaW50OmVuYWJsZTpiYW4tdHlwZXNcblxuZXhwb3J0IHR5cGUgybVQcm9taXNlUHJveHk8VD4gPSB7IFtLIGluIE5vbkZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPl06IFByb21pc2U8VFtLXT4gfSAmXG4gIHsgW0sgaW4gTm9uUHJvbWlzZVJldHVybmluZ0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl06ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFRbS10+KSA9PiBQcm9taXNlPFJldHVyblR5cGU8VFtLXT4+IH0gJlxuICB7IFtLIGluIFByb21pc2VSZXR1cm5pbmdGdW5jdGlvblByb3BlcnR5TmFtZXM8VD5dOiAoLi4uYXJnczogUGFyYW1ldGVyczxUW0tdPikgPT4gUmV0dXJuVHlwZTxUW0tdPiB9O1xuXG5cbi8vIERFQlVHIHF1aWNrIGRlYnVnZ2VyIGZ1bmN0aW9uIGZvciBpbmxpbmUgbG9nZ2luZyB0aGF0IHR5cGVzY3JpcHQgZG9lc24ndCBjb21wbGFpbiBhYm91dFxuLy8gICAgICAgd3JvdGUgaXQgZm9yIGRlYnVnZ2luZyB0aGUgybVsYXp5U0RLUHJveHksIGNvbW1lbnRpbmcgb3V0IGZvciBub3c7IHNob3VsZCBjb25zaWRlciBleHBvc2luZyBhXG4vLyAgICAgICB2ZXJib3NlIG1vZGUgZm9yIEFuZ3VsYXJGaXJlIGluIGEgZnV0dXJlIHJlbGVhc2UgdGhhdCB1c2VzIHNvbWV0aGluZyBsaWtlIHRoaXMgaW4gbXVsdGlwbGUgcGxhY2VzXG4vLyAgICAgICB1c2FnZTogKCkgPT4gbG9nKCdzb21ldGhpbmcnKSB8fCByZXR1cm5WYWx1ZVxuLy8gY29uc3QgbG9nID0gKC4uLmFyZ3M6IGFueVtdKTogZmFsc2UgPT4geyBjb25zb2xlLmxvZyguLi5hcmdzKTsgcmV0dXJuIGZhbHNlIH1cblxuLy8gVGhlIHByb2JsZW0gaGVyZSBhcmUgdGhpbmdzIGxpa2UgbmdPbkRlc3Ryb3kgYXJlIG1pc3NpbmcsIHRoZW4gdHJpZ2dlcmluZyB0aGUgc2VydmljZVxuLy8gcmF0aGVyIHRoYW4gZGlnIHRvbyBmYXI7IEknbSBjYXB0dXJpbmcgdGhlc2UgYXMgSSBnby5cbmNvbnN0IG5vb3BGdW5jdGlvbnMgPSBbJ25nT25EZXN0cm95J107XG5cbi8vIElOVkVTVElHQVRFIHNob3VsZCB3ZSBtYWtlIHRoZSBQcm94eSByZXZva2FibGUgYW5kIGRvIHNvbWUgY2xlYW51cD9cbi8vICAgICAgICAgICAgIHJpZ2h0IG5vdyBpdCdzIGZhaXJseSBzaW1wbGUgYnV0IEknbSBzdXJlIHRoaXMgd2lsbCBncm93IGluIGNvbXBsZXhpdHlcbmV4cG9ydCBjb25zdCDJtWxhenlTREtQcm94eSA9IChrbGFzczogYW55LCBvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPGFueT4sIHpvbmU6IE5nWm9uZSwgb3B0aW9uczoge1xuICBzcHk/OiB7XG4gICAgZ2V0PzogKChuYW1lOiBzdHJpbmcsIGl0OiBhbnkpID0+IHZvaWQpLFxuICAgIGFwcGx5PzogKChuYW1lOiBzdHJpbmcsIGFyZ3M6IGFueVtdLCBpdDogYW55KSA9PiB2b2lkKVxuICB9XG59ID0ge30pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShrbGFzcywge1xuICAgIGdldDogKF8sIG5hbWU6IHN0cmluZykgPT4gem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBpZiAoa2xhc3NbbmFtZV0pIHtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnNweT8uZ2V0KSB7XG4gICAgICAgICAgb3B0aW9ucy5zcHkuZ2V0KG5hbWUsIGtsYXNzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2xhc3NbbmFtZV07XG4gICAgICB9XG4gICAgICBpZiAobm9vcEZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb21pc2UgPSBvYnNlcnZhYmxlLnRvUHJvbWlzZSgpLnRoZW4obW9kID0+IHtcbiAgICAgICAgY29uc3QgcmV0ID0gbW9kICYmIG1vZFtuYW1lXTtcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRvIHByb3BlciB0eXBlIGd1YXJkc1xuICAgICAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiByZXQuYmluZChtb2QpO1xuICAgICAgICB9IGVsc2UgaWYgKHJldCAmJiByZXQudGhlbikge1xuICAgICAgICAgIHJldHVybiByZXQudGhlbigocmVzOiBhbnkpID0+IHpvbmUucnVuKCgpID0+IHJlcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB6b25lLnJ1bigoKSA9PiByZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHJlY3Vyc2UgdGhlIHByb3h5XG4gICAgICByZXR1cm4gbmV3IFByb3h5KCgpID0+IHt9LCB7XG4gICAgICAgICAgZ2V0OiAoXywgbmFtZSkgPT4gcHJvbWlzZVtuYW1lXSxcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBjYWxsYmFja3MgYXMgdHJhbnNwYXJlbnRseSBhcyBJIGNhblxuICAgICAgICAgIGFwcGx5OiAoc2VsZiwgXywgYXJncykgPT4gcHJvbWlzZS50aGVuKGl0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGl0ICYmIGl0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnNweT8uYXBwbHkpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5zcHkuYXBwbHkobmFtZSwgYXJncywgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KVxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCDJtWFwcGx5TWl4aW5zID0gKGRlcml2ZWRDdG9yOiBhbnksIGNvbnN0cnVjdG9yczogYW55W10pID0+IHtcbiAgY29uc3RydWN0b3JzLmZvckVhY2goKGJhc2VDdG9yKSA9PiB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYmFzZUN0b3IucHJvdG90eXBlIHx8IGJhc2VDdG9yKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIGRlcml2ZWRDdG9yLnByb3RvdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlQ3Rvci5wcm90b3R5cGUgfHwgYmFzZUN0b3IsIG5hbWUpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn07XG4iXX0=