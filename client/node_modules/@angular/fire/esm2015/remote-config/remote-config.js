/**
 * @fileoverview added by tsickle
 * Generated from: remote-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';
import { concat, EMPTY, Observable, of, pipe } from 'rxjs';
import { debounceTime, distinctUntilChanged, filter, groupBy, map, mergeMap, observeOn, scan, shareReplay, startWith, switchMap, tap, withLatestFrom } from 'rxjs/operators';
import { FIREBASE_APP_NAME, FIREBASE_OPTIONS, ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, ɵapplyMixins } from '@angular/fire';
import { isPlatformBrowser } from '@angular/common';
import firebase from 'firebase/app';
import { proxyPolyfillCompat } from './base';
import { ɵfetchInstance } from '@angular/fire';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
/**
 * @record
 */
export function ConfigTemplate() { }
/** @type {?} */
export const SETTINGS = new InjectionToken('angularfire2.remoteConfig.settings');
/** @type {?} */
export const DEFAULTS = new InjectionToken('angularfire2.remoteConfig.defaultConfig');
// WARNING: interface has both a type and a value, skipping emit
/** @type {?} */
const AS_TO_FN = { strings: 'asString', numbers: 'asNumber', booleans: 'asBoolean' };
/** @type {?} */
const STATIC_VALUES = { numbers: 0, booleans: false, strings: undefined };
// TODO look into the types here, I don't like the anys
/** @type {?} */
const proxyAll = (/**
 * @param {?} observable
 * @param {?} as
 * @return {?}
 */
(observable, as) => (/** @type {?} */ (new Proxy(observable.pipe(mapToObject((/** @type {?} */ (as)))), {
    get: (/**
     * @param {?} self
     * @param {?} name
     * @return {?}
     */
    (self, name) => self[name] || observable.pipe(map((/**
     * @param {?} all
     * @return {?}
     */
    all => all.find((/**
     * @param {?} p
     * @return {?}
     */
    p => p.key === name)))), map((/**
     * @param {?} param
     * @return {?}
     */
    param => param ? param[AS_TO_FN[as]]() : STATIC_VALUES[as])), distinctUntilChanged()))
}))));
const ɵ0 = proxyAll;
// TODO export as implements Partial<...> so minor doesn't break us
export class Value {
    // tslint:disable-next-line:variable-name
    /**
     * @param {?} _source
     * @param {?} _value
     */
    constructor(_source, _value) {
        this._source = _source;
        this._value = _value;
    }
    /**
     * @return {?}
     */
    asBoolean() {
        return ['1', 'true', 't', 'y', 'yes', 'on'].indexOf(this._value.toLowerCase()) > -1;
    }
    /**
     * @return {?}
     */
    asString() {
        return this._value;
    }
    /**
     * @return {?}
     */
    asNumber() {
        return Number(this._value) || 0;
    }
    /**
     * @return {?}
     */
    getSource() {
        return this._source;
    }
}
if (false) {
    /** @type {?} */
    Value.prototype._source;
    /** @type {?} */
    Value.prototype._value;
}
// SEMVER use ConstructorParameters when we can support Typescript 3.6
export class Parameter extends Value {
    /**
     * @param {?} key
     * @param {?} fetchTimeMillis
     * @param {?} source
     * @param {?} value
     */
    constructor(key, fetchTimeMillis, source, value) {
        super(source, value);
        this.key = key;
        this.fetchTimeMillis = fetchTimeMillis;
    }
}
if (false) {
    /** @type {?} */
    Parameter.prototype.key;
    /** @type {?} */
    Parameter.prototype.fetchTimeMillis;
}
// If it's a Parameter array, test any, else test the individual Parameter
/** @type {?} */
const filterTest = (/**
 * @param {?} fn
 * @return {?}
 */
(fn) => filter((/**
 * @param {?} it
 * @return {?}
 */
it => Array.isArray(it) ? it.some(fn) : fn(it))));
const ɵ1 = filterTest;
// Allow the user to bypass the default values and wait till they get something from the server, even if it's a cached copy;
// if used in conjuntion with first() it will only fetch RC values from the server if they aren't cached locally
/** @type {?} */
export const filterRemote = (/**
 * @return {?}
 */
() => filterTest((/**
 * @param {?} p
 * @return {?}
 */
p => p.getSource() === 'remote')));
// filterFresh allows the developer to effectively set up a maximum cache time
/** @type {?} */
export const filterFresh = (/**
 * @param {?} howRecentInMillis
 * @return {?}
 */
(howRecentInMillis) => filterTest((/**
 * @param {?} p
 * @return {?}
 */
p => p.fetchTimeMillis + howRecentInMillis >= new Date().getTime())));
// I ditched loading the defaults into RC and a simple map for scan since we already have our own defaults implementation.
// The idea here being that if they have a default that never loads from the server, they will be able to tell via fetchTimeMillis
// on the Parameter. Also if it doesn't come from the server it won't emit again in .changes, due to the distinctUntilChanged,
// which we can simplify to === rather than deep comparison
/** @type {?} */
const scanToParametersArray = (/**
 * @param {?} remoteConfig
 * @return {?}
 */
(remoteConfig) => pipe(withLatestFrom(remoteConfig), scan((/**
 * @param {?} existing
 * @param {?} __1
 * @return {?}
 */
(existing, [all, rc]) => {
    // SEMVER use "new Set" to unique once we're only targeting es6
    // at the scale we expect remote config to be at, we probably won't see a performance hit from this unoptimized uniqueness
    // implementation.
    // const allKeys = [...new Set([...existing.map(p => p.key), ...Object.keys(all)])];
    /** @type {?} */
    const allKeys = [...existing.map((/**
         * @param {?} p
         * @return {?}
         */
        p => p.key)), ...Object.keys(all)].filter((/**
     * @param {?} v
     * @param {?} i
     * @param {?} a
     * @return {?}
     */
    (v, i, a) => a.indexOf(v) === i));
    return allKeys.map((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        /** @type {?} */
        const updatedValue = all[key];
        return updatedValue ? new Parameter(key, rc ? rc.fetchTimeMillis : -1, updatedValue.getSource(), updatedValue.asString())
            : existing.find((/**
             * @param {?} p
             * @return {?}
             */
            p => p.key === key));
    }));
}), (/** @type {?} */ ([])))));
const ɵ2 = scanToParametersArray;
export class AngularFireRemoteConfig {
    /**
     * @param {?} options
     * @param {?} nameOrConfig
     * @param {?} settings
     * @param {?} defaultConfig
     * @param {?} zone
     * @param {?} platformId
     */
    constructor(options, nameOrConfig, settings, defaultConfig, zone, 
    // tslint:disable-next-line:ban-types
    platformId) {
        this.zone = zone;
        /** @type {?} */
        const schedulers = new ɵAngularFireSchedulers(zone);
        /** @type {?} */
        const remoteConfig$ = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap((/**
         * @return {?}
         */
        () => isPlatformBrowser(platformId) ? import('firebase/remote-config') : EMPTY)), switchMap((/**
         * @return {?}
         */
        () => import('@firebase/remote-config'))), tap((/**
         * @param {?} rc
         * @return {?}
         */
        rc => rc.registerRemoteConfig && rc.registerRemoteConfig((/** @type {?} */ (firebase))))), map((/**
         * @return {?}
         */
        () => ɵfirebaseAppFactory(options, zone, nameOrConfig))), map((/**
         * @param {?} app
         * @return {?}
         */
        app => ɵfetchInstance(`${app.name}.remote-config`, 'AngularFireRemoteConfig', app, (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const rc = app.remoteConfig();
            if (settings) {
                rc.settings = settings;
            }
            if (defaultConfig) {
                rc.defaultConfig = defaultConfig;
            }
            return rc;
        }), [settings, defaultConfig]))), 
        // tslint:disable-next-line
        startWith(undefined), shareReplay({ bufferSize: 1, refCount: false }));
        /** @type {?} */
        const loadedRemoteConfig$ = remoteConfig$.pipe(filter((/**
         * @param {?} rc
         * @return {?}
         */
        rc => !!rc)));
        /** @type {?} */
        const default$ = of(Object.keys(defaultConfig || {}).reduce((/**
         * @param {?} c
         * @param {?} k
         * @return {?}
         */
        (c, k) => (Object.assign(Object.assign({}, c), { [k]: new Value('default', defaultConfig[k].toString()) }))), {}));
        // we should filter out the defaults we provided to RC, since we have our own implementation
        // that gives us a -1 for fetchTimeMillis (so filterFresh can filter them out)
        /** @type {?} */
        const filterOutDefaults = map((/**
         * @param {?} all
         * @return {?}
         */
        all => Object.keys(all)
            .filter((/**
         * @param {?} key
         * @return {?}
         */
        key => all[key].getSource() !== 'default'))
            .reduce((/**
         * @param {?} acc
         * @param {?} key
         * @return {?}
         */
        (acc, key) => (Object.assign(Object.assign({}, acc), { [key]: all[key] }))), {})));
        /** @type {?} */
        const existing$ = loadedRemoteConfig$.pipe(switchMap((/**
         * @param {?} rc
         * @return {?}
         */
        rc => rc.activate()
            .then((/**
         * @return {?}
         */
        () => rc.ensureInitialized()))
            .then((/**
         * @return {?}
         */
        () => rc.getAll())))), filterOutDefaults);
        /** @type {?} */
        const fresh$ = loadedRemoteConfig$.pipe(switchMap((/**
         * @param {?} rc
         * @return {?}
         */
        rc => zone.runOutsideAngular((/**
         * @return {?}
         */
        () => rc.fetchAndActivate()
            .then((/**
         * @return {?}
         */
        () => rc.ensureInitialized()))
            .then((/**
         * @return {?}
         */
        () => rc.getAll())))))), filterOutDefaults);
        this.parameters = concat(default$, existing$, fresh$).pipe(scanToParametersArray(remoteConfig$), ɵkeepUnstableUntilFirstFactory(schedulers), shareReplay({ bufferSize: 1, refCount: true }));
        this.changes = this.parameters.pipe(switchMap((/**
         * @param {?} params
         * @return {?}
         */
        params => of(...params))), groupBy((/**
         * @param {?} param
         * @return {?}
         */
        param => param.key)), mergeMap((/**
         * @param {?} group
         * @return {?}
         */
        group => group.pipe(distinctUntilChanged()))));
        this.strings = proxyAll(this.parameters, 'strings');
        this.booleans = proxyAll(this.parameters, 'booleans');
        this.numbers = proxyAll(this.parameters, 'numbers');
        return ɵlazySDKProxy(this, loadedRemoteConfig$, zone);
    }
}
AngularFireRemoteConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'any'
            },] }
];
/** @nocollapse */
AngularFireRemoteConfig.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEFAULTS,] }] },
    { type: NgZone },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/** @nocollapse */ AngularFireRemoteConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFireRemoteConfig_Factory() { return new AngularFireRemoteConfig(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(DEFAULTS, 8), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.PLATFORM_ID)); }, token: AngularFireRemoteConfig, providedIn: "any" });
if (false) {
    /** @type {?} */
    AngularFireRemoteConfig.prototype.changes;
    /** @type {?} */
    AngularFireRemoteConfig.prototype.parameters;
    /** @type {?} */
    AngularFireRemoteConfig.prototype.numbers;
    /** @type {?} */
    AngularFireRemoteConfig.prototype.booleans;
    /** @type {?} */
    AngularFireRemoteConfig.prototype.strings;
    /**
     * @type {?}
     * @private
     */
    AngularFireRemoteConfig.prototype.zone;
}
/** @type {?} */
export const budget = (/**
 * @template T
 * @param {?} interval
 * @return {?}
 */
(interval) => (/**
 * @param {?} source
 * @return {?}
 */
(source) => new Observable((/**
 * @param {?} observer
 * @return {?}
 */
observer => {
    /** @type {?} */
    let timedOut = false;
    // TODO use scheduler task rather than settimeout
    /** @type {?} */
    const timeout = setTimeout((/**
     * @return {?}
     */
    () => {
        observer.complete();
        timedOut = true;
    }), interval);
    return source.subscribe({
        /**
         * @param {?} val
         * @return {?}
         */
        next(val) {
            if (!timedOut) {
                observer.next(val);
            }
        },
        /**
         * @param {?} err
         * @return {?}
         */
        error(err) {
            if (!timedOut) {
                clearTimeout(timeout);
                observer.error(err);
            }
        },
        /**
         * @return {?}
         */
        complete() {
            if (!timedOut) {
                clearTimeout(timeout);
                observer.complete();
            }
        }
    });
}))));
/** @type {?} */
const typedMethod = (/**
 * @param {?} it
 * @return {?}
 */
(it) => {
    switch (typeof it) {
        case 'string':
            return 'asString';
        case 'boolean':
            return 'asBoolean';
        case 'number':
            return 'asNumber';
        default:
            return 'asString';
    }
});
const ɵ3 = typedMethod;
/**
 * @template T
 * @param {?=} to
 * @return {?}
 */
export function scanToObject(to = 'strings') {
    return pipe(
    // TODO cleanup
    scan((/**
     * @param {?} c
     * @param {?} p
     * @return {?}
     */
    (c, p) => (Object.assign(Object.assign({}, c), { [p.key]: typeof to === 'object' ?
            p[typedMethod(to[p.key])]() :
            p[AS_TO_FN[to]]() }))), typeof to === 'object' ?
        (/** @type {?} */ (to)) :
        (/** @type {?} */ ({}))), debounceTime(1), budget(10), distinctUntilChanged((/**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    (a, b) => JSON.stringify(a) === JSON.stringify(b))));
}
/**
 * @template T
 * @param {?=} to
 * @return {?}
 */
export function mapToObject(to = 'strings') {
    return pipe(
    // TODO this is getting a little long, cleanup
    map((/**
     * @param {?} params
     * @return {?}
     */
    (params) => params.reduce((/**
     * @param {?} c
     * @param {?} p
     * @return {?}
     */
    (c, p) => (Object.assign(Object.assign({}, c), { [p.key]: typeof to === 'object' ?
            p[typedMethod(to[p.key])]() :
            p[AS_TO_FN[to]]() }))), typeof to === 'object' ?
        (/** @type {?} */ (to)) :
        (/** @type {?} */ ({}))))), distinctUntilChanged((/**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    (a, b) => JSON.stringify(a) === JSON.stringify(b))));
}
ɵapplyMixins(AngularFireRemoteConfig, [proxyPolyfillCompat]);
export { ɵ0, ɵ1, ɵ2, ɵ3 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVtb3RlLWNvbmZpZy5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9hbmd1bGFyZmlyZS9hbmd1bGFyZmlyZS9zcmMvcmVtb3RlLWNvbmZpZy8iLCJzb3VyY2VzIjpbInJlbW90ZS1jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEcsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQTRCLFVBQVUsRUFBRSxFQUFFLEVBQW9CLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN2RyxPQUFPLEVBQ0wsWUFBWSxFQUNaLG9CQUFvQixFQUNwQixNQUFNLEVBQ04sT0FBTyxFQUNQLEdBQUcsRUFDSCxRQUFRLEVBQ1IsU0FBUyxFQUNULElBQUksRUFDSixXQUFXLEVBQ1gsU0FBUyxFQUNULFNBQVMsRUFDVCxHQUFHLEVBQ0gsY0FBYyxFQUNmLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixnQkFBZ0IsRUFHaEIsc0JBQXNCLEVBQ3RCLG1CQUFtQixFQUNuQiw4QkFBOEIsRUFDOUIsYUFBYSxFQUViLFlBQVksRUFDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLFFBQVEsTUFBTSxjQUFjLENBQUM7QUFFcEMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7OztBQUUvQyxvQ0FFQzs7QUFFRCxNQUFNLE9BQU8sUUFBUSxHQUFHLElBQUksY0FBYyxDQUFXLG9DQUFvQyxDQUFDOztBQUMxRixNQUFNLE9BQU8sUUFBUSxHQUFHLElBQUksY0FBYyxDQUFp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QSxFQUFFLEVBQWdELENBQ3JELEVBQUMsRUFDRixvQkFBb0I7Ozs7O0lBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FDeEUsQ0FBQztBQUNKLENBQUM7QUFFRCxZQUFZLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBOZ1pvbmUsIE9wdGlvbmFsLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29uY2F0LCBFTVBUWSwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlLCBvZiwgT3BlcmF0b3JGdW5jdGlvbiwgcGlwZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgZGVib3VuY2VUaW1lLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgZmlsdGVyLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBvYnNlcnZlT24sXG4gIHNjYW4sXG4gIHNoYXJlUmVwbGF5LFxuICBzdGFydFdpdGgsXG4gIHN3aXRjaE1hcCxcbiAgdGFwLFxuICB3aXRoTGF0ZXN0RnJvbVxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBGSVJFQkFTRV9BUFBfTkFNRSxcbiAgRklSRUJBU0VfT1BUSU9OUyxcbiAgRmlyZWJhc2VBcHBDb25maWcsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMsXG4gIMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5LFxuICDJtWxhenlTREtQcm94eSxcbiAgybVQcm9taXNlUHJveHksXG4gIMm1YXBwbHlNaXhpbnNcbn0gZnJvbSAnQGFuZ3VsYXIvZmlyZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHByb3h5UG9seWZpbGxDb21wYXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgybVmZXRjaEluc3RhbmNlIH0gZnJvbSAnQGFuZ3VsYXIvZmlyZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnVGVtcGxhdGUge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW48U2V0dGluZ3M+KCdhbmd1bGFyZmlyZTIucmVtb3RlQ29uZmlnLnNldHRpbmdzJyk7XG5leHBvcnQgY29uc3QgREVGQVVMVFMgPSBuZXcgSW5qZWN0aW9uVG9rZW48Q29uZmlnVGVtcGxhdGU+KCdhbmd1bGFyZmlyZTIucmVtb3RlQ29uZmlnLmRlZmF1bHRDb25maWcnKTtcblxuZXhwb3J0IGludGVyZmFjZSBBbmd1bGFyRmlyZVJlbW90ZUNvbmZpZyBleHRlbmRzIMm1UHJvbWlzZVByb3h5PGZpcmViYXNlLnJlbW90ZUNvbmZpZy5SZW1vdGVDb25maWc+IHtcbn1cblxuY29uc3QgQVNfVE9fRk4gPSB7IHN0cmluZ3M6ICdhc1N0cmluZycsIG51bWJlcnM6ICdhc051bWJlcicsIGJvb2xlYW5zOiAnYXNCb29sZWFuJyB9O1xuY29uc3QgU1RBVElDX1ZBTFVFUyA9IHsgbnVtYmVyczogMCwgYm9vbGVhbnM6IGZhbHNlLCBzdHJpbmdzOiB1bmRlZmluZWQgfTtcblxuLy8gVE9ETyBsb29rIGludG8gdGhlIHR5cGVzIGhlcmUsIEkgZG9uJ3QgbGlrZSB0aGUgYW55c1xuY29uc3QgcHJveHlBbGwgPSAob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxQYXJhbWV0ZXJbXT4sIGFzOiAnbnVtYmVycycgfCAnYm9vbGVhbnMnIHwgJ3N0cmluZ3MnKSA9PiBuZXcgUHJveHkoXG4gIG9ic2VydmFibGUucGlwZShtYXBUb09iamVjdChhcyBhcyBhbnkpKSwge1xuICAgIGdldDogKHNlbGYsIG5hbWU6IHN0cmluZykgPT4gc2VsZltuYW1lXSB8fCBvYnNlcnZhYmxlLnBpcGUoXG4gICAgICBtYXAoYWxsID0+IGFsbC5maW5kKHAgPT4gcC5rZXkgPT09IG5hbWUpKSxcbiAgICAgIG1hcChwYXJhbSA9PiBwYXJhbSA/IHBhcmFtW0FTX1RPX0ZOW2FzXV0oKSA6IFNUQVRJQ19WQUxVRVNbYXNdKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApXG4gIH1cbikgYXMgYW55O1xuXG4vLyBUT0RPIGV4cG9ydCBhcyBpbXBsZW1lbnRzIFBhcnRpYWw8Li4uPiBzbyBtaW5vciBkb2Vzbid0IGJyZWFrIHVzXG5leHBvcnQgY2xhc3MgVmFsdWUgaW1wbGVtZW50cyBmaXJlYmFzZS5yZW1vdGVDb25maWcuVmFsdWUge1xuICBhc0Jvb2xlYW4oKSB7XG4gICAgcmV0dXJuIFsnMScsICd0cnVlJywgJ3QnLCAneScsICd5ZXMnLCAnb24nXS5pbmRleE9mKHRoaXMuX3ZhbHVlLnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBhc051bWJlcigpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuX3ZhbHVlKSB8fCAwO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICBjb25zdHJ1Y3RvcihwdWJsaWMgX3NvdXJjZTogZmlyZWJhc2UucmVtb3RlQ29uZmlnLlZhbHVlU291cmNlLCBwdWJsaWMgX3ZhbHVlOiBzdHJpbmcpIHtcbiAgfVxufVxuXG4vLyBTRU1WRVIgdXNlIENvbnN0cnVjdG9yUGFyYW1ldGVycyB3aGVuIHdlIGNhbiBzdXBwb3J0IFR5cGVzY3JpcHQgMy42XG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyIGV4dGVuZHMgVmFsdWUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMga2V5OiBzdHJpbmcsIHB1YmxpYyBmZXRjaFRpbWVNaWxsaXM6IG51bWJlciwgc291cmNlOiBmaXJlYmFzZS5yZW1vdGVDb25maWcuVmFsdWVTb3VyY2UsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzb3VyY2UsIHZhbHVlKTtcbiAgfVxufVxuXG4vLyBJZiBpdCdzIGEgUGFyYW1ldGVyIGFycmF5LCB0ZXN0IGFueSwgZWxzZSB0ZXN0IHRoZSBpbmRpdmlkdWFsIFBhcmFtZXRlclxuY29uc3QgZmlsdGVyVGVzdCA9IChmbjogKHBhcmFtOiBQYXJhbWV0ZXIpID0+IGJvb2xlYW4pID0+IGZpbHRlcjxQYXJhbWV0ZXIgfCBQYXJhbWV0ZXJbXT4oaXQgPT4gQXJyYXkuaXNBcnJheShpdCkgPyBpdC5zb21lKGZuKSA6IGZuKGl0KSk7XG5cbi8vIEFsbG93IHRoZSB1c2VyIHRvIGJ5cGFzcyB0aGUgZGVmYXVsdCB2YWx1ZXMgYW5kIHdhaXQgdGlsbCB0aGV5IGdldCBzb21ldGhpbmcgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIGl0J3MgYSBjYWNoZWQgY29weTtcbi8vIGlmIHVzZWQgaW4gY29uanVudGlvbiB3aXRoIGZpcnN0KCkgaXQgd2lsbCBvbmx5IGZldGNoIFJDIHZhbHVlcyBmcm9tIHRoZSBzZXJ2ZXIgaWYgdGhleSBhcmVuJ3QgY2FjaGVkIGxvY2FsbHlcbmV4cG9ydCBjb25zdCBmaWx0ZXJSZW1vdGUgPSAoKSA9PiBmaWx0ZXJUZXN0KHAgPT4gcC5nZXRTb3VyY2UoKSA9PT0gJ3JlbW90ZScpO1xuXG4vLyBmaWx0ZXJGcmVzaCBhbGxvd3MgdGhlIGRldmVsb3BlciB0byBlZmZlY3RpdmVseSBzZXQgdXAgYSBtYXhpbXVtIGNhY2hlIHRpbWVcbmV4cG9ydCBjb25zdCBmaWx0ZXJGcmVzaCA9IChob3dSZWNlbnRJbk1pbGxpczogbnVtYmVyKSA9PiBmaWx0ZXJUZXN0KHAgPT4gcC5mZXRjaFRpbWVNaWxsaXMgKyBob3dSZWNlbnRJbk1pbGxpcyA+PSBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cblxuLy8gSSBkaXRjaGVkIGxvYWRpbmcgdGhlIGRlZmF1bHRzIGludG8gUkMgYW5kIGEgc2ltcGxlIG1hcCBmb3Igc2NhbiBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgb3VyIG93biBkZWZhdWx0cyBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoZSBpZGVhIGhlcmUgYmVpbmcgdGhhdCBpZiB0aGV5IGhhdmUgYSBkZWZhdWx0IHRoYXQgbmV2ZXIgbG9hZHMgZnJvbSB0aGUgc2VydmVyLCB0aGV5IHdpbGwgYmUgYWJsZSB0byB0ZWxsIHZpYSBmZXRjaFRpbWVNaWxsaXNcbi8vIG9uIHRoZSBQYXJhbWV0ZXIuIEFsc28gaWYgaXQgZG9lc24ndCBjb21lIGZyb20gdGhlIHNlcnZlciBpdCB3b24ndCBlbWl0IGFnYWluIGluIC5jaGFuZ2VzLCBkdWUgdG8gdGhlIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuLy8gd2hpY2ggd2UgY2FuIHNpbXBsaWZ5IHRvID09PSByYXRoZXIgdGhhbiBkZWVwIGNvbXBhcmlzb25cbmNvbnN0IHNjYW5Ub1BhcmFtZXRlcnNBcnJheSA9IChcbiAgcmVtb3RlQ29uZmlnOiBPYnNlcnZhYmxlPGZpcmViYXNlLnJlbW90ZUNvbmZpZy5SZW1vdGVDb25maWcgfCB1bmRlZmluZWQ+XG4pOiBPcGVyYXRvckZ1bmN0aW9uPHsgW2tleTogc3RyaW5nXTogZmlyZWJhc2UucmVtb3RlQ29uZmlnLlZhbHVlIH0sIFBhcmFtZXRlcltdPiA9PiBwaXBlKFxuICB3aXRoTGF0ZXN0RnJvbShyZW1vdGVDb25maWcpLFxuICBzY2FuKChleGlzdGluZywgW2FsbCwgcmNdKSA9PiB7XG4gICAgLy8gU0VNVkVSIHVzZSBcIm5ldyBTZXRcIiB0byB1bmlxdWUgb25jZSB3ZSdyZSBvbmx5IHRhcmdldGluZyBlczZcbiAgICAvLyBhdCB0aGUgc2NhbGUgd2UgZXhwZWN0IHJlbW90ZSBjb25maWcgdG8gYmUgYXQsIHdlIHByb2JhYmx5IHdvbid0IHNlZSBhIHBlcmZvcm1hbmNlIGhpdCBmcm9tIHRoaXMgdW5vcHRpbWl6ZWQgdW5pcXVlbmVzc1xuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIGNvbnN0IGFsbEtleXMgPSBbLi4ubmV3IFNldChbLi4uZXhpc3RpbmcubWFwKHAgPT4gcC5rZXkpLCAuLi5PYmplY3Qua2V5cyhhbGwpXSldO1xuICAgIGNvbnN0IGFsbEtleXMgPSBbLi4uZXhpc3RpbmcubWFwKHAgPT4gcC5rZXkpLCAuLi5PYmplY3Qua2V5cyhhbGwpXS5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG4gICAgcmV0dXJuIGFsbEtleXMubWFwKGtleSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkVmFsdWUgPSBhbGxba2V5XTtcbiAgICAgIHJldHVybiB1cGRhdGVkVmFsdWUgPyBuZXcgUGFyYW1ldGVyKGtleSwgcmMgPyByYy5mZXRjaFRpbWVNaWxsaXMgOiAtMSwgdXBkYXRlZFZhbHVlLmdldFNvdXJjZSgpLCB1cGRhdGVkVmFsdWUuYXNTdHJpbmcoKSlcbiAgICAgICAgOiBleGlzdGluZy5maW5kKHAgPT4gcC5rZXkgPT09IGtleSk7XG4gICAgfSk7XG4gIH0sIFtdIGFzIEFycmF5PFBhcmFtZXRlcj4pXG4pO1xuXG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ2FueSdcbn0pXG5leHBvcnQgY2xhc3MgQW5ndWxhckZpcmVSZW1vdGVDb25maWcge1xuXG4gIHJlYWRvbmx5IGNoYW5nZXM6IE9ic2VydmFibGU8UGFyYW1ldGVyPjtcbiAgcmVhZG9ubHkgcGFyYW1ldGVyczogT2JzZXJ2YWJsZTxQYXJhbWV0ZXJbXT47XG4gIHJlYWRvbmx5IG51bWJlcnM6IE9ic2VydmFibGU8eyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCB1bmRlZmluZWQgfT4gJiB7IFtrZXk6IHN0cmluZ106IE9ic2VydmFibGU8bnVtYmVyPiB9O1xuICByZWFkb25seSBib29sZWFuczogT2JzZXJ2YWJsZTx7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQgfT4gJiB7IFtrZXk6IHN0cmluZ106IE9ic2VydmFibGU8Ym9vbGVhbj4gfTtcbiAgcmVhZG9ubHkgc3RyaW5nczogT2JzZXJ2YWJsZTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9PiAmIHsgW2tleTogc3RyaW5nXTogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+IH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChGSVJFQkFTRV9PUFRJT05TKSBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChGSVJFQkFTRV9BUFBfTkFNRSkgbmFtZU9yQ29uZmlnOiBzdHJpbmcgfCBGaXJlYmFzZUFwcENvbmZpZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChTRVRUSU5HUykgc2V0dGluZ3M6IFNldHRpbmdzIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERFRkFVTFRTKSBkZWZhdWx0Q29uZmlnOiBDb25maWdUZW1wbGF0ZSB8IG51bGwsXG4gICAgcHJpdmF0ZSB6b25lOiBOZ1pvbmUsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhbi10eXBlc1xuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHtcblxuICAgIGNvbnN0IHNjaGVkdWxlcnMgPSBuZXcgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMoem9uZSk7XG5cbiAgICBjb25zdCByZW1vdGVDb25maWckID0gb2YodW5kZWZpbmVkKS5waXBlKFxuICAgICAgb2JzZXJ2ZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgc3dpdGNoTWFwKCgpID0+IGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpID8gaW1wb3J0KCdmaXJlYmFzZS9yZW1vdGUtY29uZmlnJykgOiBFTVBUWSksXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gaW1wb3J0KCdAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZycpKSxcbiAgICAgIHRhcChyYyA9PiByYy5yZWdpc3RlclJlbW90ZUNvbmZpZyAmJiByYy5yZWdpc3RlclJlbW90ZUNvbmZpZyhmaXJlYmFzZSBhcyBhbnkpKSxcbiAgICAgIG1hcCgoKSA9PiDJtWZpcmViYXNlQXBwRmFjdG9yeShvcHRpb25zLCB6b25lLCBuYW1lT3JDb25maWcpKSxcbiAgICAgIG1hcChhcHAgPT4gybVmZXRjaEluc3RhbmNlKGAke2FwcC5uYW1lfS5yZW1vdGUtY29uZmlnYCwgJ0FuZ3VsYXJGaXJlUmVtb3RlQ29uZmlnJywgYXBwLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJjID0gYXBwLnJlbW90ZUNvbmZpZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICByYy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgICAgcmMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSwgW3NldHRpbmdzLCBkZWZhdWx0Q29uZmlnXSkpLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICBzdGFydFdpdGgodW5kZWZpbmVkKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IGZhbHNlIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGxvYWRlZFJlbW90ZUNvbmZpZyQgPSByZW1vdGVDb25maWckLnBpcGUoXG4gICAgICBmaWx0ZXI8ZmlyZWJhc2UucmVtb3RlQ29uZmlnLlJlbW90ZUNvbmZpZz4ocmMgPT4gISFyYylcbiAgICApO1xuXG4gICAgY29uc3QgZGVmYXVsdCQ6IE9ic2VydmFibGU8eyBba2V5OiBzdHJpbmddOiBmaXJlYmFzZS5yZW1vdGVDb25maWcuVmFsdWUgfT4gPSBvZihPYmplY3Qua2V5cyhkZWZhdWx0Q29uZmlnIHx8IHt9KS5yZWR1Y2UoXG4gICAgICAoYywgaykgPT4gKHsgLi4uYywgW2tdOiBuZXcgVmFsdWUoJ2RlZmF1bHQnLCBkZWZhdWx0Q29uZmlnW2tdLnRvU3RyaW5nKCkpIH0pLCB7fVxuICAgICkpO1xuXG4gICAgLy8gd2Ugc2hvdWxkIGZpbHRlciBvdXQgdGhlIGRlZmF1bHRzIHdlIHByb3ZpZGVkIHRvIFJDLCBzaW5jZSB3ZSBoYXZlIG91ciBvd24gaW1wbGVtZW50YXRpb25cbiAgICAvLyB0aGF0IGdpdmVzIHVzIGEgLTEgZm9yIGZldGNoVGltZU1pbGxpcyAoc28gZmlsdGVyRnJlc2ggY2FuIGZpbHRlciB0aGVtIG91dClcbiAgICBjb25zdCBmaWx0ZXJPdXREZWZhdWx0cyA9IG1hcDx7IFtrZXk6IHN0cmluZ106IGZpcmViYXNlLnJlbW90ZUNvbmZpZy5WYWx1ZSB9LCB7IFtrZXk6IHN0cmluZ106IGZpcmViYXNlLnJlbW90ZUNvbmZpZy5WYWx1ZSB9PihhbGwgPT5cbiAgICAgIE9iamVjdC5rZXlzKGFsbClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gYWxsW2tleV0uZ2V0U291cmNlKCkgIT09ICdkZWZhdWx0JylcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGFsbFtrZXldIH0pLCB7fSlcbiAgICApO1xuXG4gICAgY29uc3QgZXhpc3RpbmckID0gbG9hZGVkUmVtb3RlQ29uZmlnJC5waXBlKFxuICAgICAgc3dpdGNoTWFwKHJjID0+XG4gICAgICAgIHJjLmFjdGl2YXRlKClcbiAgICAgICAgICAudGhlbigoKSA9PiByYy5lbnN1cmVJbml0aWFsaXplZCgpKVxuICAgICAgICAgIC50aGVuKCgpID0+IHJjLmdldEFsbCgpKVxuICAgICAgKSxcbiAgICAgIGZpbHRlck91dERlZmF1bHRzXG4gICAgKTtcblxuICAgIGNvbnN0IGZyZXNoJCA9IGxvYWRlZFJlbW90ZUNvbmZpZyQucGlwZShcbiAgICAgIHN3aXRjaE1hcChyYyA9PiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgIHJjLmZldGNoQW5kQWN0aXZhdGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHJjLmVuc3VyZUluaXRpYWxpemVkKCkpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gcmMuZ2V0QWxsKCkpXG4gICAgICApKSxcbiAgICAgIGZpbHRlck91dERlZmF1bHRzXG4gICAgKTtcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IGNvbmNhdChkZWZhdWx0JCwgZXhpc3RpbmckLCBmcmVzaCQpLnBpcGUoXG4gICAgICBzY2FuVG9QYXJhbWV0ZXJzQXJyYXkocmVtb3RlQ29uZmlnJCksXG4gICAgICDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KHNjaGVkdWxlcnMpLFxuICAgICAgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KVxuICAgICk7XG5cbiAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLnBhcmFtZXRlcnMucGlwZShcbiAgICAgIHN3aXRjaE1hcChwYXJhbXMgPT4gb2YoLi4ucGFyYW1zKSksXG4gICAgICBncm91cEJ5KHBhcmFtID0+IHBhcmFtLmtleSksXG4gICAgICBtZXJnZU1hcChncm91cCA9PiBncm91cC5waXBlKFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApKVxuICAgICk7XG5cbiAgICB0aGlzLnN0cmluZ3MgPSBwcm94eUFsbCh0aGlzLnBhcmFtZXRlcnMsICdzdHJpbmdzJyk7XG4gICAgdGhpcy5ib29sZWFucyA9IHByb3h5QWxsKHRoaXMucGFyYW1ldGVycywgJ2Jvb2xlYW5zJyk7XG4gICAgdGhpcy5udW1iZXJzID0gcHJveHlBbGwodGhpcy5wYXJhbWV0ZXJzLCAnbnVtYmVycycpO1xuXG4gICAgcmV0dXJuIMm1bGF6eVNES1Byb3h5KHRoaXMsIGxvYWRlZFJlbW90ZUNvbmZpZyQsIHpvbmUpO1xuICB9XG5cbn1cblxuXG5leHBvcnQgY29uc3QgYnVkZ2V0ID0gPFQ+KGludGVydmFsOiBudW1iZXIpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4gPT4gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gbmV3IE9ic2VydmFibGU8VD4ob2JzZXJ2ZXIgPT4ge1xuICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgLy8gVE9ETyB1c2Ugc2NoZWR1bGVyIHRhc2sgcmF0aGVyIHRoYW4gc2V0dGltZW91dFxuICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB0aW1lZE91dCA9IHRydWU7XG4gIH0sIGludGVydmFsKTtcbiAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xuICAgIG5leHQodmFsKSB7XG4gICAgICBpZiAoIXRpbWVkT3V0KSB7XG4gICAgICAgIG9ic2VydmVyLm5leHQodmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVycm9yKGVycikge1xuICAgICAgaWYgKCF0aW1lZE91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICghdGltZWRPdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KTtcblxuY29uc3QgdHlwZWRNZXRob2QgPSAoaXQ6IGFueSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBpdCkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJ2FzU3RyaW5nJztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAnYXNCb29sZWFuJztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuICdhc051bWJlcic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnYXNTdHJpbmcnO1xuICB9XG59O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FuVG9PYmplY3QoKTogT3BlcmF0b3JGdW5jdGlvbjxQYXJhbWV0ZXIsIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Ub09iamVjdCh0bzogJ251bWJlcnMnKTogT3BlcmF0b3JGdW5jdGlvbjxQYXJhbWV0ZXIsIHsgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Ub09iamVjdCh0bzogJ2Jvb2xlYW5zJyk6IE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyLCB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQgfT47XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dW5pZmllZC1zaWduYXR1cmVzXG5leHBvcnQgZnVuY3Rpb24gc2NhblRvT2JqZWN0KHRvOiAnc3RyaW5ncycpOiBPcGVyYXRvckZ1bmN0aW9uPFBhcmFtZXRlciwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfT47XG5leHBvcnQgZnVuY3Rpb24gc2NhblRvT2JqZWN0PFQgZXh0ZW5kcyBDb25maWdUZW1wbGF0ZT4odGVtcGxhdGU6IFQpOiBPcGVyYXRvckZ1bmN0aW9uPFBhcmFtZXRlciwgVCAmIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Ub09iamVjdDxUIGV4dGVuZHMgQ29uZmlnVGVtcGxhdGU+KHRvOiAnbnVtYmVycycgfCAnYm9vbGVhbnMnIHwgJ3N0cmluZ3MnIHwgVCA9ICdzdHJpbmdzJykge1xuICByZXR1cm4gcGlwZShcbiAgICAvLyBUT0RPIGNsZWFudXBcbiAgICBzY2FuKFxuICAgICAgKGMsIHA6IFBhcmFtZXRlcikgPT4gKHtcbiAgICAgICAgLi4uYywgW3Aua2V5XTogdHlwZW9mIHRvID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgcFt0eXBlZE1ldGhvZCh0b1twLmtleV0pXSgpIDpcbiAgICAgICAgICBwW0FTX1RPX0ZOW3RvXV0oKVxuICAgICAgfSksXG4gICAgICB0eXBlb2YgdG8gPT09ICdvYmplY3QnID9cbiAgICAgICAgdG8gYXMgVCAmIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gOlxuICAgICAgICB7fSBhcyB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfVxuICAgICksXG4gICAgZGVib3VuY2VUaW1lKDEpLFxuICAgIGJ1ZGdldCgxMCksXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKGEsIGIpID0+IEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvT2JqZWN0KCk6IE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyW10sIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvT2JqZWN0KHRvOiAnbnVtYmVycycpOiBPcGVyYXRvckZ1bmN0aW9uPFBhcmFtZXRlcltdLCB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IHVuZGVmaW5lZCB9PjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb09iamVjdCh0bzogJ2Jvb2xlYW5zJyk6IE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyW10sIHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB8IHVuZGVmaW5lZCB9Pjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1bmlmaWVkLXNpZ25hdHVyZXNcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb09iamVjdCh0bzogJ3N0cmluZ3MnKTogT3BlcmF0b3JGdW5jdGlvbjxQYXJhbWV0ZXJbXSwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfT47XG5leHBvcnQgZnVuY3Rpb24gbWFwVG9PYmplY3Q8VCBleHRlbmRzIENvbmZpZ1RlbXBsYXRlPih0ZW1wbGF0ZTogVCk6XG4gIE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyW10sIFQgJiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9PjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb09iamVjdDxUIGV4dGVuZHMgQ29uZmlnVGVtcGxhdGU+KHRvOiAnbnVtYmVycycgfCAnYm9vbGVhbnMnIHwgJ3N0cmluZ3MnIHwgVCA9ICdzdHJpbmdzJykge1xuICByZXR1cm4gcGlwZShcbiAgICAvLyBUT0RPIHRoaXMgaXMgZ2V0dGluZyBhIGxpdHRsZSBsb25nLCBjbGVhbnVwXG4gICAgbWFwKChwYXJhbXM6IFBhcmFtZXRlcltdKSA9PiBwYXJhbXMucmVkdWNlKFxuICAgICAgKGMsIHApID0+ICh7XG4gICAgICAgIC4uLmMsIFtwLmtleV06IHR5cGVvZiB0byA9PT0gJ29iamVjdCcgP1xuICAgICAgICAgIHBbdHlwZWRNZXRob2QodG9bcC5rZXldKV0oKSA6XG4gICAgICAgICAgcFtBU19UT19GTlt0b11dKClcbiAgICAgIH0pLFxuICAgICAgdHlwZW9mIHRvID09PSAnb2JqZWN0JyA/XG4gICAgICAgIHRvIGFzIFQgJiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9IDpcbiAgICAgICAge30gYXMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBib29sZWFuIHwgc3RyaW5nIH1cbiAgICApKSxcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgoYSwgYikgPT4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpKVxuICApO1xufVxuXG7JtWFwcGx5TWl4aW5zKEFuZ3VsYXJGaXJlUmVtb3RlQ29uZmlnLCBbcHJveHlQb2x5ZmlsbENvbXBhdF0pO1xuIl19