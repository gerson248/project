(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('firebase/auth'), require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/fire'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@angular/fire/auth', ['exports', 'firebase/auth', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/fire', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.angular = global.angular || {}, global.angular.fire = global.angular.fire || {}, global.angular.fire.auth = {}), null, global.ng.core, global.rxjs, global.rxjs.operators, global.angular.fire, global.ng.common));
}(this, (function (exports, auth, i0, rxjs, operators, i1, common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: base.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var proxyPolyfillCompat = {
        app: null,
        applyActionCode: null,
        checkActionCode: null,
        confirmPasswordReset: null,
        createUserWithEmailAndPassword: null,
        currentUser: null,
        fetchSignInMethodsForEmail: null,
        isSignInWithEmailLink: null,
        getRedirectResult: null,
        languageCode: null,
        settings: null,
        onAuthStateChanged: null,
        onIdTokenChanged: null,
        sendSignInLinkToEmail: null,
        sendPasswordResetEmail: null,
        setPersistence: null,
        signInAndRetrieveDataWithCredential: null,
        signInAnonymously: null,
        signInWithCredential: null,
        signInWithCustomToken: null,
        signInWithEmailAndPassword: null,
        signInWithPhoneNumber: null,
        signInWithEmailLink: null,
        signInWithPopup: null,
        signInWithRedirect: null,
        signOut: null,
        tenantId: null,
        updateCurrentUser: null,
        useDeviceLanguage: null,
        useEmulator: null,
        verifyPasswordResetCode: null,
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: auth.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // WARNING: interface has both a type and a value, skipping emit
    /** @type {?} */
    var USE_EMULATOR = new i0.InjectionToken('angularfire2.auth.use-emulator');
    /** @type {?} */
    var SETTINGS = new i0.InjectionToken('angularfire2.auth.settings');
    /** @type {?} */
    var TENANT_ID = new i0.InjectionToken('angularfire2.auth.tenant-id');
    /** @type {?} */
    var LANGUAGE_CODE = new i0.InjectionToken('angularfire2.auth.langugage-code');
    /** @type {?} */
    var USE_DEVICE_LANGUAGE = new i0.InjectionToken('angularfire2.auth.use-device-language');
    /** @type {?} */
    var PERSISTENCE = new i0.InjectionToken('angularfire.auth.persistence');
    var AngularFireAuth = /** @class */ (function () {
        /**
         * @param {?} options
         * @param {?} nameOrConfig
         * @param {?} platformId
         * @param {?} zone
         * @param {?} _useEmulator
         * @param {?} _settings
         * @param {?} tenantId
         * @param {?} languageCode
         * @param {?} useDeviceLanguage
         * @param {?} persistence
         */
        function AngularFireAuth(options, nameOrConfig, 
        // tslint:disable-next-line:ban-types
        platformId, zone, _useEmulator, // can't use the tuple here
        _settings, // can't use firebase.auth.AuthSettings here
        tenantId, languageCode, useDeviceLanguage, persistence) {
            /** @type {?} */
            var schedulers = new i1.ɵAngularFireSchedulers(zone);
            /** @type {?} */
            var keepUnstableUntilFirst = i1.ɵkeepUnstableUntilFirstFactory(schedulers);
            /** @type {?} */
            var logins = new rxjs.Subject();
            /** @type {?} */
            var auth = rxjs.of(undefined).pipe(operators.observeOn(schedulers.outsideAngular), operators.switchMap(( /**
             * @return {?}
             */function () { return zone.runOutsideAngular(( /**
             * @return {?}
             */function () { return rxjs.of(undefined); })); })), operators.map(( /**
             * @return {?}
             */function () { return i1.ɵfirebaseAppFactory(options, zone, nameOrConfig); })), operators.map(( /**
             * @param {?} app
             * @return {?}
             */function (/**
             * @param {?} app
             * @return {?}
             */ app) { return zone.runOutsideAngular(( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var useEmulator = _useEmulator;
                /** @type {?} */
                var settings = _settings;
                return i1.ɵfetchInstance(app.name + ".auth", 'AngularFireAuth', app, ( /**
                 * @return {?}
                 */function () {
                    /** @type {?} */
                    var auth = zone.runOutsideAngular(( /**
                     * @return {?}
                     */function () { return app.auth(); }));
                    if (useEmulator) {
                        // Firebase Auth doesn't conform to the useEmulator convention, let's smooth that over
                        auth.useEmulator("http://" + useEmulator.join(':'));
                    }
                    if (tenantId) {
                        auth.tenantId = tenantId;
                    }
                    auth.languageCode = languageCode;
                    if (useDeviceLanguage) {
                        auth.useDeviceLanguage();
                    }
                    if (settings) {
                        auth.settings = settings;
                    }
                    if (persistence) {
                        auth.setPersistence(persistence);
                    }
                    return auth;
                }), [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);
            })); })), operators.shareReplay({ bufferSize: 1, refCount: false }));
            if (common.isPlatformServer(platformId)) {
                this.authState = this.user = this.idToken = this.idTokenResult = this.credential = rxjs.of(null);
            }
            else {
                // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth
                //       (e.g, `import { auth } from 'firebase/app'`) are getting an undefined auth object unexpectedly
                //       as we're completely lazy. Let's eagerly load the Auth SDK here.
                //       There could potentially be race conditions still... but this greatly decreases the odds while
                //       we reevaluate the API.
                /** @type {?} */
                var _ = auth.pipe(operators.first()).subscribe();
                /** @type {?} */
                var redirectResult = auth.pipe(operators.switchMap(( /**
                 * @param {?} auth
                 * @return {?}
                 */function (/**
                 * @param {?} auth
                 * @return {?}
                 */ auth) { return auth.getRedirectResult().then(( /**
                 * @param {?} it
                 * @return {?}
                 */function (/**
                 * @param {?} it
                 * @return {?}
                 */ it) { return it; }), ( /**
                 * @return {?}
                 */function () { return null; })); })), keepUnstableUntilFirst, operators.shareReplay({ bufferSize: 1, refCount: false }));
                /** @type {?} */
                var fromCallback_1 = ( /**
                 * @template T
                 * @param {?} cb
                 * @return {?}
                 */function (cb) { return new rxjs.Observable(( /**
                 * @param {?} subscriber
                 * @return {?}
                 */function (/**
                 * @param {?} subscriber
                 * @return {?}
                 */ subscriber) { return ({ unsubscribe: zone.runOutsideAngular(( /**
                         * @return {?}
                         */function () { return cb(subscriber); })) }); })); });
                /** @type {?} */
                var authStateChanged = auth.pipe(operators.switchMap(( /**
                 * @param {?} auth
                 * @return {?}
                 */function (/**
                 * @param {?} auth
                 * @return {?}
                 */ auth) { return fromCallback_1(auth.onAuthStateChanged.bind(auth)); })));
                /** @type {?} */
                var idTokenChanged = auth.pipe(operators.switchMap(( /**
                 * @param {?} auth
                 * @return {?}
                 */function (/**
                 * @param {?} auth
                 * @return {?}
                 */ auth) { return fromCallback_1(auth.onIdTokenChanged.bind(auth)); })));
                this.authState = redirectResult.pipe(operators.switchMapTo(authStateChanged), operators.subscribeOn(schedulers.outsideAngular), operators.observeOn(schedulers.insideAngular));
                this.user = redirectResult.pipe(operators.switchMapTo(idTokenChanged), operators.subscribeOn(schedulers.outsideAngular), operators.observeOn(schedulers.insideAngular));
                this.idToken = this.user.pipe(operators.switchMap(( /**
                 * @param {?} user
                 * @return {?}
                 */function (/**
                 * @param {?} user
                 * @return {?}
                 */ user) { return user ? rxjs.from(user.getIdToken()) : rxjs.of(null); })));
                this.idTokenResult = this.user.pipe(operators.switchMap(( /**
                 * @param {?} user
                 * @return {?}
                 */function (/**
                 * @param {?} user
                 * @return {?}
                 */ user) { return user ? rxjs.from(user.getIdTokenResult()) : rxjs.of(null); })));
                this.credential = rxjs.merge(redirectResult, logins, 
                // pipe in null authState to make credential zipable, just a weird devexp if
                // authState and user go null to still have a credential
                this.authState.pipe(operators.filter(( /**
                 * @param {?} it
                 * @return {?}
                 */function (/**
                 * @param {?} it
                 * @return {?}
                 */ it) { return !it; })))).pipe(
                // handle the { user: { } } when a user is already logged in, rather have null
                // TODO handle the type corcersion better
                operators.map(( /**
                 * @param {?} credential
                 * @return {?}
                 */function (/**
                 * @param {?} credential
                 * @return {?}
                 */ credential) { return (credential === null || credential === void 0 ? void 0 : credential.user) ? ( /** @type {?} */(credential)) : null; })), operators.subscribeOn(schedulers.outsideAngular), operators.observeOn(schedulers.insideAngular));
            }
            return i1.ɵlazySDKProxy(this, auth, zone, { spy: {
                    apply: ( /**
                     * @param {?} name
                     * @param {?} _
                     * @param {?} val
                     * @return {?}
                     */function (name, _, val) {
                        // If they call a signIn or createUser function listen into the promise
                        // this will give us the user credential, push onto the logins Subject
                        // to be consumed in .credential
                        if (name.startsWith('signIn') || name.startsWith('createUser')) {
                            // TODO fix the types, the trouble is UserCredential has everything optional
                            val.then(( /**
                             * @param {?} user
                             * @return {?}
                             */function (user) { return logins.next(( /** @type {?} */(user))); }));
                        }
                    })
                } });
        }
        return AngularFireAuth;
    }());
    AngularFireAuth.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'any'
                },] }
    ];
    /** @nocollapse */
    AngularFireAuth.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.FIREBASE_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.FIREBASE_APP_NAME,] }] },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [USE_EMULATOR,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [SETTINGS,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [TENANT_ID,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [LANGUAGE_CODE,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [USE_DEVICE_LANGUAGE,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [PERSISTENCE,] }] }
    ]; };
    /** @nocollapse */ AngularFireAuth.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFireAuth_Factory() { return new AngularFireAuth(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8)); }, token: AngularFireAuth, providedIn: "any" });
    if (false) {
        /**
         * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out
         * @type {?}
         */
        AngularFireAuth.prototype.authState;
        /**
         * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).
         * @type {?}
         */
        AngularFireAuth.prototype.idToken;
        /**
         * Observable of the currently signed-in user (or null).
         * @type {?}
         */
        AngularFireAuth.prototype.user;
        /**
         * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other
         * helper properties for getting different data associated with the token as well as all the decoded payload claims
         * (or null).
         * @type {?}
         */
        AngularFireAuth.prototype.idTokenResult;
        /**
         * Observable of the currently signed-in user's credential, or null
         * @type {?}
         */
        AngularFireAuth.prototype.credential;
    }
    i1.ɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);

    /**
     * @fileoverview added by tsickle
     * Generated from: auth.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AngularFireAuthModule = /** @class */ (function () {
        function AngularFireAuthModule() {
        }
        return AngularFireAuthModule;
    }());
    AngularFireAuthModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [AngularFireAuth]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: angular-fire-auth.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.AngularFireAuth = AngularFireAuth;
    exports.AngularFireAuthModule = AngularFireAuthModule;
    exports.LANGUAGE_CODE = LANGUAGE_CODE;
    exports.PERSISTENCE = PERSISTENCE;
    exports.SETTINGS = SETTINGS;
    exports.TENANT_ID = TENANT_ID;
    exports.USE_DEVICE_LANGUAGE = USE_DEVICE_LANGUAGE;
    exports.USE_EMULATOR = USE_EMULATOR;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-fire-auth.umd.js.map
