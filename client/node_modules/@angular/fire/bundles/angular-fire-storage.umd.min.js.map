{"version":3,"sources":["../../../src/storage/observable/fromTask.ts","../../../src/storage/task.ts","../../../src/storage/ref.ts","../../../src/storage/storage.ts","../../../src/storage/pipes/storageUrl.pipe.ts","../../../src/storage/storage.module.ts"],"names":["fromTask","task","Observable","subscriber","progress","snap","next","snapshot","unsub","on","then","complete","e","error","pipe","debounceTime","createUploadTask","inner$","bind","catch","pause","cancel","resume","snapshotChanges","percentageChanges","map","s","bytesTransferred","totalBytes","createStorageRef","ref","schedulers","keepUnstableUntilFirst","getDownloadURL","of","undefined","observeOn","outsideAngular","switchMap","getMetadata","delete","from","child","path","updateMetadata","meta","put","data","metadata","putString","format","listAll","BUCKET","InjectionToken","MAX_UPLOAD_RETRY_TIME","MAX_OPERATION_RETRY_TIME","AngularFireStorage","options","nameOrConfig","storageBucket","platformId","zone","maxUploadRetryTime","maxOperationRetryTime","this","ɵAngularFireSchedulers","ɵkeepUnstableUntilFirstFactory","app","ɵfirebaseAppFactory","storage","ɵfetchInstance","name","runOutsideAngular","setMaxUploadRetryTime","setMaxOperationRetryTime","prototype","refFromURL","upload","Injectable","args","providedIn","Inject","FIREBASE_OPTIONS","Optional","type","FIREBASE_APP_NAME","Object","decorators","PLATFORM_ID","NgZone","GetDownloadURLPipe","cdr","asyncPipe","AsyncPipe","transform","downloadUrl$","ngOnDestroy","Pipe","pure","ChangeDetectorRef","NgModule","declarations","exports","GetDownloadURLPipeModule","providers"],"mappings":"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","sourcesContent":["import { Observable } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { UploadTask, UploadTaskSnapshot } from '../interfaces';\n\n// need to import, else the types become import('firebase/app').default.storage.UploadTask\n// and it no longer works w/Firebase v7\nimport firebase from 'firebase/app';\n\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\nexport function fromTask(task: UploadTask) {\n  return new Observable<UploadTaskSnapshot>(subscriber => {\n    const progress = (snap: UploadTaskSnapshot) => subscriber.next(snap);\n    const error = e => subscriber.error(e);\n    const complete = () => subscriber.complete();\n    // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n    progress(task.snapshot);\n    const unsub = task.on('state_changed', progress);\n    // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n    task.then(snapshot => {\n      progress(snapshot);\n      complete();\n    }, e => {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    });\n    // on's type if Function, rather than () => void, need to wrap\n    return function unsubscribe() {\n      unsub();\n    };\n  }).pipe(\n    // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n    // that if the task is already finished we don't emit the old running state\n    debounceTime(0)\n  );\n}\n","import { UploadTask, UploadTaskSnapshot } from './interfaces';\nimport { fromTask } from './observable/fromTask';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport interface AngularFireUploadTask {\n  task: UploadTask;\n  snapshotChanges(): Observable<UploadTaskSnapshot | undefined>;\n  percentageChanges(): Observable<number | undefined>;\n  pause(): boolean;\n  cancel(): boolean;\n  resume(): boolean;\n  then(\n    onFulfilled?: ((a: UploadTaskSnapshot) => any) | null,\n    onRejected?: ((a: Error) => any) | null\n  ): Promise<any>;\n  catch(onRejected: (a: Error) => any): Promise<any>;\n}\n\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\nexport function createUploadTask(task: UploadTask): AngularFireUploadTask {\n  const inner$ = fromTask(task);\n  return {\n    task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: () => inner$,\n    percentageChanges: () => inner$.pipe(\n      map(s => s.bytesTransferred / s.totalBytes * 100)\n    )\n  };\n}\n","import { ListResult, Reference, SettableMetadata, StringFormat, UploadMetadata } from './interfaces';\nimport { AngularFireUploadTask, createUploadTask } from './task';\nimport { from, Observable, of } from 'rxjs';\nimport { ɵAngularFireSchedulers } from '@angular/fire';\nimport { observeOn, switchMap } from 'rxjs/operators';\n\nexport interface AngularFireStorageReference {\n  getDownloadURL(): Observable<any>;\n  getMetadata(): Observable<any>;\n  delete(): Observable<any>;\n  child(path: string): any;\n  updateMetadata(meta: SettableMetadata): Observable<any>;\n  put(data: any, metadata?: UploadMetadata | undefined): AngularFireUploadTask;\n  putString(data: string, format?: string | undefined, metadata?: UploadMetadata | undefined): AngularFireUploadTask;\n  listAll(): Observable<ListResult>;\n}\n\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\nexport function createStorageRef(\n  ref: Reference,\n  schedulers: ɵAngularFireSchedulers,\n  keepUnstableUntilFirst: <T>(obs$: Observable<T>) => Observable<T>\n): AngularFireStorageReference {\n  return {\n    getDownloadURL: () => of(undefined).pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(() => ref.getDownloadURL()),\n      keepUnstableUntilFirst\n    ),\n    getMetadata: () => of(undefined).pipe(\n      observeOn(schedulers.outsideAngular),\n      switchMap(() => ref.getMetadata()),\n      keepUnstableUntilFirst\n    ),\n    delete: () => from(ref.delete()),\n    child: (path: string) => createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst),\n    updateMetadata: (meta: SettableMetadata) => from(ref.updateMetadata(meta)),\n    put: (data: any, metadata?: UploadMetadata) => {\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: (data: string, format?: StringFormat, metadata?: UploadMetadata) => {\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll: () => from(ref.listAll())\n  };\n}\n","import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { createStorageRef } from './ref';\nimport { Observable } from 'rxjs';\nimport {\n  FIREBASE_APP_NAME,\n  FIREBASE_OPTIONS,\n  FirebaseAppConfig,\n  FirebaseOptions,\n  ɵAngularFireSchedulers,\n  ɵfetchInstance,\n  ɵfirebaseAppFactory,\n  ɵkeepUnstableUntilFirstFactory\n} from '@angular/fire';\nimport { UploadMetadata } from './interfaces';\nimport 'firebase/storage';\nimport firebase from 'firebase/app';\n\nexport const BUCKET = new InjectionToken<string>('angularfire2.storageBucket');\nexport const MAX_UPLOAD_RETRY_TIME = new InjectionToken<number>('angularfire2.storage.maxUploadRetryTime');\nexport const MAX_OPERATION_RETRY_TIME = new InjectionToken<number>('angularfire2.storage.maxOperationRetryTime');\n\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFireStorage {\n  public readonly storage: firebase.storage.Storage;\n\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig: string | FirebaseAppConfig | null | undefined,\n    @Optional() @Inject(BUCKET) storageBucket: string | null,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(MAX_UPLOAD_RETRY_TIME) maxUploadRetryTime: number | any,\n    @Optional() @Inject(MAX_OPERATION_RETRY_TIME) maxOperationRetryTime: number | any,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n    const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n    this.storage = ɵfetchInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app, () => {\n      const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n      if (maxUploadRetryTime) {\n        storage.setMaxUploadRetryTime(maxUploadRetryTime);\n      }\n      if (maxOperationRetryTime) {\n        storage.setMaxOperationRetryTime(maxOperationRetryTime);\n      }\n      return storage;\n    }, [maxUploadRetryTime, maxOperationRetryTime]);\n  }\n\n  ref(path: string) {\n    return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n  }\n\n  refFromURL(path: string) {\n    return createStorageRef(this.storage.refFromURL(path), this.schedulers, this.keepUnstableUntilFirst);\n  }\n\n  upload(path: string, data: any, metadata?: UploadMetadata) {\n    const storageRef = this.storage.ref(path);\n    const ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n    return ref.put(data, metadata);\n  }\n\n}\n","import { AsyncPipe } from '@angular/common';\nimport { ChangeDetectorRef, NgModule, OnDestroy, Pipe, PipeTransform } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { AngularFireStorage } from '../storage';\n\n/** to be used with in combination with | async */\n@Pipe({\n  name: 'getDownloadURL',\n  pure: false,\n})\nexport class GetDownloadURLPipe implements PipeTransform, OnDestroy {\n\n  private asyncPipe: AsyncPipe;\n  private path: string;\n  private downloadUrl$: Observable<any>;\n\n  constructor(private storage: AngularFireStorage, cdr: ChangeDetectorRef) {\n    this.asyncPipe = new AsyncPipe(cdr);\n  }\n\n  transform(path: string) {\n    if (path !== this.path) {\n      this.path = path;\n      this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n    }\n    return this.asyncPipe.transform(this.downloadUrl$);\n  }\n\n  ngOnDestroy() {\n    this.asyncPipe.ngOnDestroy();\n  }\n\n}\n\n@NgModule({\n  declarations: [ GetDownloadURLPipe ],\n  exports: [ GetDownloadURLPipe ],\n})\nexport class GetDownloadURLPipeModule {}\n","import { NgModule } from '@angular/core';\nimport { GetDownloadURLPipeModule } from './pipes/storageUrl.pipe';\nimport { AngularFireStorage } from './storage';\n\n@NgModule({\n  exports: [ GetDownloadURLPipeModule ],\n  providers: [ AngularFireStorage ]\n})\nexport class AngularFireStorageModule { }\n"]}