{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../src/firestore/observable/fromRef.ts","../../../src/firestore/collection/changes.ts","../../../src/firestore/collection/collection.ts","../../../src/firestore/document/document.ts","../../../src/firestore/collection-group/collection-group.ts","../../../src/firestore/firestore.ts","../../../src/firestore/firestore.module.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","fromRef","ref","scheduler","rxjs","asyncScheduler","Observable","subscriber","unsubscribe","schedule","onSnapshot","includeMetadataChanges","_fromRef","fromDocRef","pipe","startWith","undefined","pairwise","map","_a","_b","priorPayload","payload","exists","type","fromCollectionRef","docChanges","query","priorAction","action","actions","change","JSON","stringify","metadata","docs","forEach","currentDoc","currentIndex","docChange","find","d","doc","isEqual","priorDoc","oldIndex","newIndex","sortedChanges","events","scan","current","changes","combineChanges","it","distinctUntilChanged","c","indexOf","combineChange","sliceAndSplice","original","start","deleteCount","args","_i","returnArray","slice","splice","apply","combined","copiedArray","validateEventsArray","AngularFirestoreCollection","afs","this","prototype","stateChanges","source","schedulers","outsideAngular","filter","prior","keepUnstableUntilFirst","auditTrail","snapshotChanges","validatedEvents","valueChanges","options","a","idField","assign","data","id","get","from","observeOn","insideAngular","add","path","AngularFirestoreDocument","set","update","delete","collection","queryFn","associateQuery","AngularFirestoreCollectionGroup","ENABLE_PERSISTENCE","InjectionToken","PERSISTENCE_SETTINGS","SETTINGS","USE_EMULATOR","collectionRef","AngularFirestore","nameOrConfig","shouldEnablePersistence","settings","platformId","zone","persistenceSettings","_useEmulator","useAuthEmulator","ɵAngularFireSchedulers","ɵkeepUnstableUntilFirstFactory","app","ɵfirebaseAppFactory","firebase","auth","ɵlogAuthEmulatorError","useEmulator","ɵfetchInstance","name","firestore","runOutsideAngular","isPlatformServer","enablePersistence","then","console","warn","of","persistenceEnabled$","pathOrRef","refInZone","ngZone","run","collectionGroup","collectionId","queryGroupFn","createId","Injectable","providedIn","Inject","FIREBASE_OPTIONS","Optional","FIREBASE_APP_NAME","decorators","PLATFORM_ID","NgZone","USE_AUTH_EMULATOR","AngularFirestoreModule","ngModule","providers","provide","useValue","NgModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { asyncScheduler, Observable, SchedulerLike } from 'rxjs';\nimport { Action, DocumentReference, DocumentSnapshot, Query, QuerySnapshot, Reference } from '../interfaces';\nimport { map, pairwise, startWith } from 'rxjs/operators';\n\nfunction _fromRef<T, R>(ref: Reference<T>, scheduler: SchedulerLike = asyncScheduler): Observable<R> {\n  return new Observable(subscriber => {\n    let unsubscribe: () => void;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n    }\n\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\n\nexport function fromRef<R, T>(ref: DocumentReference<T> | Query<T>, scheduler?: SchedulerLike) {\n  return _fromRef<typeof ref, R>(ref, scheduler);\n}\n\nexport function fromDocRef<T>(ref: DocumentReference<T>, scheduler?: SchedulerLike): Observable<Action<DocumentSnapshot<T>>> {\n  return fromRef<DocumentSnapshot<T>, T>(ref, scheduler)\n    .pipe(\n      startWith(undefined),\n      pairwise(),\n      map(([priorPayload, payload]) => {\n        if (!payload.exists) {\n          return { payload, type: 'removed' };\n        }\n        if (!priorPayload?.exists) {\n          return { payload, type: 'added' };\n        }\n        return { payload, type: 'modified' };\n      })\n    );\n}\n\nexport function fromCollectionRef<T>(ref: Query<T>, scheduler?: SchedulerLike): Observable<Action<QuerySnapshot<T>>> {\n  return fromRef<QuerySnapshot<T>, T>(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n","import { fromCollectionRef } from '../observable/fromRef';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { distinctUntilChanged, map, pairwise, scan, startWith } from 'rxjs/operators';\nimport { DocumentChange, DocumentChangeAction, DocumentChangeType, Query } from '../interfaces';\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      startWith(undefined),\n      pairwise(),\n      map(([priorAction, action]) => {\n        const docChanges = action.payload.docChanges();\n        const actions = docChanges.map(change => ({ type: change.type, payload: change }));\n        // the metadata has changed from the prior emission\n        if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n          // go through all the docs in payload and figure out which ones changed\n          action.payload.docs.forEach((currentDoc, currentIndex) => {\n            const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n            const priorDoc = priorAction?.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n            if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) ||\n              !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n              // document doesn't appear to have changed, don't log another action\n            } else {\n              // since the actions are processed in order just push onto the array\n              actions.push({\n                type: 'modified',\n                payload: {\n                  oldIndex: currentIndex,\n                  newIndex: currentIndex,\n                  type: 'modified',\n                  doc: currentDoc\n                }\n              });\n            }\n          });\n        }\n        return actions as DocumentChangeAction<T>[];\n      }),\n  );\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nexport function sortedChanges<T>(\n  query: Query,\n  events: DocumentChangeType[],\n  scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return docChanges<T>(query, scheduler)\n    .pipe(\n      scan((current, changes) => combineChanges<T>(current, changes.map(it => it.payload), events), []),\n      distinctUntilChanged(), // cut down on unneed change cycles\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice<T>(\n  original: T[],\n  start: number,\n  deleteCount: number,\n  ...args: T[]\n): T[] {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n","import { from, Observable } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { filter, map, observeOn, pairwise, scan, startWith } from 'rxjs/operators';\nimport firebase from 'firebase/app';\n\nimport { CollectionReference, DocumentChangeAction, DocumentChangeType, DocumentData, DocumentReference, Query } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T = DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(\n    public readonly ref: CollectionReference<T>,\n    private readonly query: Query<T>,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    let source = docChanges<T>(this.query, this.afs.schedulers.outsideAngular);\n    if (events && events.length > 0) {\n      source = source.pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1))\n      );\n    }\n    return source.pipe(\n      // We want to filter out empty arrays, but always emit at first, so the developer knows\n      // that the collection has been resolve; even if it's empty\n      startWith(undefined),\n      pairwise(),\n      filter(([prior, current]) => current.length > 0 || !prior),\n      map(([prior, current]) => current),\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // tslint:disable-next-line:unified-signatures\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as {},\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference<T>> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   */\n  doc<T2 = T>(path?: string): AngularFirestoreDocument<T2> {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path) as any, this.afs);\n  }\n}\n","import { from, Observable } from 'rxjs';\nimport { Action, DocumentData, DocumentReference, DocumentSnapshot, QueryFn, SetOptions } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport firebase from 'firebase/app';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T = DocumentData> {\n\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(public ref: DocumentReference<T>, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n  collection<R = DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path) as firebase.firestore.CollectionReference<R>;\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(options?: { }): Observable<T | undefined>;\n  valueChanges<K extends string>(options: { idField: K }): Observable<(T & { [T in K]: string }) | undefined>;\n  valueChanges<K extends string>(options: { idField?: K } = {}): Observable<T | undefined> {\n    return this.snapshotChanges().pipe(\n      map(({ payload }) =>\n        options.idField ? {\n          ...payload.data(),\n          ...{ [options.idField]: payload.id }\n        } as T & { [T in K]: string } : payload.data()\n      )\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n}\n","import { from, Observable } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { filter, map, observeOn, scan } from 'rxjs/operators';\nimport firebase from 'firebase/app';\n\nimport { DocumentChangeAction, DocumentChangeType, DocumentData, Query } from '../interfaces';\nimport { validateEventsArray } from '../collection/collection';\nimport { docChanges, sortedChanges } from '../collection/changes';\nimport { AngularFirestore } from '../firestore';\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollectionGroup<T = DocumentData> {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(\n    private readonly query: Query<T>,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if (!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // tslint:disable-next-line:unified-signatures\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    const fromCollectionRefScheduled$ = fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              [options.idField]: a.id,\n              ...a.data()\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular)\n    );\n  }\n\n}\n","import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { from, Observable, of } from 'rxjs';\nimport {\n  AssociatedReference,\n  CollectionReference,\n  DocumentReference,\n  PersistenceSettings,\n  Query,\n  QueryFn,\n  QueryGroupFn,\n  Settings\n} from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport {\n  FIREBASE_APP_NAME,\n  FIREBASE_OPTIONS,\n  FirebaseAppConfig,\n  FirebaseOptions,\n  ɵAngularFireSchedulers,\n  ɵfirebaseAppFactory,\n  ɵkeepUnstableUntilFirstFactory,\n  FirebaseApp\n} from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { USE_EMULATOR as USE_AUTH_EMULATOR } from '@angular/fire/auth';\nimport { ɵfetchInstance, ɵlogAuthEmulatorError } from '@angular/fire';\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const ENABLE_PERSISTENCE = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PERSISTENCE_SETTINGS = new InjectionToken<PersistenceSettings | undefined>('angularfire2.firestore.persistenceSettings');\nexport const SETTINGS = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\n// SEMVER(7): use Parameters to detirmine the useEmulator arguments\n// type UseEmulatorArguments = Parameters<typeof firebase.firestore.Firestore.prototype.useEmulator>;\ntype UseEmulatorArguments = [string, number];\nexport const USE_EMULATOR = new InjectionToken<UseEmulatorArguments>('angularfire2.firestore.use-emulator');\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery<T>(collectionRef: CollectionReference<T>, queryFn = ref => ref): AssociatedReference<T> {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\ntype InstanceCache = Map<FirebaseApp, [\n  firebase.firestore.Firestore,\n  firebase.firestore.Settings | null,\n  UseEmulatorArguments | null,\n  boolean | null]\n>;\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirestore {\n  public readonly firestore: firebase.firestore.Firestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig: string | FirebaseAppConfig | null | undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean | null,\n    @Optional() @Inject(SETTINGS) settings: Settings | null,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings | null,\n    @Optional() @Inject(USE_EMULATOR) _useEmulator: any,\n    @Optional() @Inject(USE_AUTH_EMULATOR) useAuthEmulator: any,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n\n    const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n    if (!firebase.auth && useAuthEmulator) {\n      ɵlogAuthEmulatorError();\n    }\n    const useEmulator: UseEmulatorArguments | null = _useEmulator;\n\n    [this.firestore, this.persistenceEnabled$] = ɵfetchInstance(`${app.name}.firestore`, 'AngularFirestore', app, () => {\n      const firestore = zone.runOutsideAngular(() => app.firestore());\n      if (settings) {\n        firestore.settings(settings);\n      }\n      if (useEmulator) {\n        firestore.useEmulator(...useEmulator);\n      }\n\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n        const enablePersistence = () => {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n          } catch (e) {\n            if (typeof console !== 'undefined') { console.warn(e); }\n            return of(false);\n          }\n        };\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n\n    }, [settings, useEmulator, shouldEnablePersistence]);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  // tslint:disable-next-line:unified-signatures\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  collection<T>(pathOrRef: string | CollectionReference<T>, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference<T>;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef) as firebase.firestore.CollectionReference<T>;\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery<T>(collectionRef, queryFn);\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreCollection<T>(refInZone, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn<T>): AngularFirestoreCollectionGroup<T> {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup: Query<T> = this.firestore.collectionGroup(collectionId) as firebase.firestore.Query<T>;\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>;\n  // tslint:disable-next-line:unified-signatures\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>;\n  doc<T>(pathOrRef: string | DocumentReference<T>): AngularFirestoreDocument<T> {\n    let ref: DocumentReference<T>;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef) as firebase.firestore.DocumentReference<T>;\n    } else {\n      ref = pathOrRef;\n    }\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreDocument<T>(refInZone, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { PersistenceSettings } from './interfaces';\nimport { AngularFirestore, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS } from './firestore';\n\n@NgModule({\n  providers: [ AngularFirestore ]\n})\nexport class AngularFirestoreModule {\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings?: PersistenceSettings): ModuleWithProviders<AngularFirestoreModule> {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [\n        { provide: ENABLE_PERSISTENCE, useValue: true },\n        { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n      ]\n    };\n  }\n}\n"]}