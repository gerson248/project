(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@angular/fire'), require('firebase/storage'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@angular/fire/storage', ['exports', 'rxjs', 'rxjs/operators', '@angular/core', '@angular/fire', 'firebase/storage', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.angular = global.angular || {}, global.angular.fire = global.angular.fire || {}, global.angular.fire.storage = {}), global.rxjs, global.rxjs.operators, global.ng.core, global.angular.fire, null, global.ng.common));
}(this, (function (exports, rxjs, operators, i0, i1, storage, common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * Generated from: observable/fromTask.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // Things aren't working great, I'm having to put in a lot of work-arounds for what
    // appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158
    /**
     * @param {?} task
     * @return {?}
     */
    function fromTask(task) {
        return new rxjs.Observable(( /**
         * @param {?} subscriber
         * @return {?}
         */function (/**
         * @param {?} subscriber
         * @return {?}
         */ subscriber) {
            /** @type {?} */
            var progress = ( /**
             * @param {?} snap
             * @return {?}
             */function (snap) { return subscriber.next(snap); });
            /** @type {?} */
            var error = ( /**
             * @param {?} e
             * @return {?}
             */function (/**
             * @param {?} e
             * @return {?}
             */ e) { return subscriber.error(e); });
            /** @type {?} */
            var complete = ( /**
             * @return {?}
             */function () { return subscriber.complete(); });
            // emit the current snapshot, so they don't have to wait for state_changes
            // to fire next... this is stale if the task is no longer running :(
            progress(task.snapshot);
            /** @type {?} */
            var unsub = task.on('state_changed', progress);
            // it turns out that neither task snapshot nor 'state_changed' fire the last
            // snapshot before completion, the one with status 'success" and 100% progress
            // so let's use the promise form of the task for that
            task.then(( /**
             * @param {?} snapshot
             * @return {?}
             */function (/**
             * @param {?} snapshot
             * @return {?}
             */ snapshot) {
                progress(snapshot);
                complete();
            }), ( /**
             * @param {?} e
             * @return {?}
             */function (/**
             * @param {?} e
             * @return {?}
             */ e) {
                // TODO investigate, again this is stale, we never fire a canceled or error it seems
                progress(task.snapshot);
                error(e);
            }));
            // on's type if Function, rather than () => void, need to wrap
            return ( /**
             * @return {?}
             */function unsubscribe() {
                unsub();
            });
        })).pipe(
        // deal with sync emissions from first emitting `task.snapshot`, this makes sure
        // that if the task is already finished we don't emit the old running state
        operators.debounceTime(0));
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: task.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function AngularFireUploadTask() { }
    if (false) {
        /** @type {?} */
        AngularFireUploadTask.prototype.task;
        /**
         * @return {?}
         */
        AngularFireUploadTask.prototype.snapshotChanges = function () { };
        /**
         * @return {?}
         */
        AngularFireUploadTask.prototype.percentageChanges = function () { };
        /**
         * @return {?}
         */
        AngularFireUploadTask.prototype.pause = function () { };
        /**
         * @return {?}
         */
        AngularFireUploadTask.prototype.cancel = function () { };
        /**
         * @return {?}
         */
        AngularFireUploadTask.prototype.resume = function () { };
        /**
         * @param {?=} onFulfilled
         * @param {?=} onRejected
         * @return {?}
         */
        AngularFireUploadTask.prototype.then = function (onFulfilled, onRejected) { };
        /**
         * @param {?} onRejected
         * @return {?}
         */
        AngularFireUploadTask.prototype.catch = function (onRejected) { };
    }
    /**
     * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.
     * This method creates an observable of the upload and returns on object that provides
     * multiple methods for controlling and monitoring the file upload.
     * @param {?} task
     * @return {?}
     */
    function createUploadTask(task) {
        /** @type {?} */
        var inner$ = fromTask(task);
        return {
            task: task,
            then: task.then.bind(task),
            catch: task.catch.bind(task),
            pause: task.pause.bind(task),
            cancel: task.cancel.bind(task),
            resume: task.resume.bind(task),
            snapshotChanges: ( /**
             * @return {?}
             */function () { return inner$; }),
            percentageChanges: ( /**
             * @return {?}
             */function () { return inner$.pipe(operators.map(( /**
             * @param {?} s
             * @return {?}
             */function (/**
             * @param {?} s
             * @return {?}
             */ s) { return s.bytesTransferred / s.totalBytes * 100; }))); })
        };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: ref.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function AngularFireStorageReference() { }
    if (false) {
        /**
         * @return {?}
         */
        AngularFireStorageReference.prototype.getDownloadURL = function () { };
        /**
         * @return {?}
         */
        AngularFireStorageReference.prototype.getMetadata = function () { };
        /**
         * @return {?}
         */
        AngularFireStorageReference.prototype.delete = function () { };
        /**
         * @param {?} path
         * @return {?}
         */
        AngularFireStorageReference.prototype.child = function (path) { };
        /**
         * @param {?} meta
         * @return {?}
         */
        AngularFireStorageReference.prototype.updateMetadata = function (meta) { };
        /**
         * @param {?} data
         * @param {?=} metadata
         * @return {?}
         */
        AngularFireStorageReference.prototype.put = function (data, metadata) { };
        /**
         * @param {?} data
         * @param {?=} format
         * @param {?=} metadata
         * @return {?}
         */
        AngularFireStorageReference.prototype.putString = function (data, format, metadata) { };
        /**
         * @return {?}
         */
        AngularFireStorageReference.prototype.listAll = function () { };
    }
    /**
     * Create an AngularFire wrapped Storage Reference. This object
     * creates observable methods from promise based methods.
     * @param {?} ref
     * @param {?} schedulers
     * @param {?} keepUnstableUntilFirst
     * @return {?}
     */
    function createStorageRef(ref, schedulers, keepUnstableUntilFirst) {
        return {
            getDownloadURL: ( /**
             * @return {?}
             */function () { return rxjs.of(undefined).pipe(operators.observeOn(schedulers.outsideAngular), operators.switchMap(( /**
             * @return {?}
             */function () { return ref.getDownloadURL(); })), keepUnstableUntilFirst); }),
            getMetadata: ( /**
             * @return {?}
             */function () { return rxjs.of(undefined).pipe(operators.observeOn(schedulers.outsideAngular), operators.switchMap(( /**
             * @return {?}
             */function () { return ref.getMetadata(); })), keepUnstableUntilFirst); }),
            delete: ( /**
             * @return {?}
             */function () { return rxjs.from(ref.delete()); }),
            child: ( /**
             * @param {?} path
             * @return {?}
             */function (path) { return createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst); }),
            updateMetadata: ( /**
             * @param {?} meta
             * @return {?}
             */function (meta) { return rxjs.from(ref.updateMetadata(meta)); }),
            put: ( /**
             * @param {?} data
             * @param {?=} metadata
             * @return {?}
             */function (data, metadata) {
                /** @type {?} */
                var task = ref.put(data, metadata);
                return createUploadTask(task);
            }),
            putString: ( /**
             * @param {?} data
             * @param {?=} format
             * @param {?=} metadata
             * @return {?}
             */function (data, format, metadata) {
                /** @type {?} */
                var task = ref.putString(data, format, metadata);
                return createUploadTask(task);
            }),
            listAll: ( /**
             * @return {?}
             */function () { return rxjs.from(ref.listAll()); })
        };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: storage.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BUCKET = new i0.InjectionToken('angularfire2.storageBucket');
    /** @type {?} */
    var MAX_UPLOAD_RETRY_TIME = new i0.InjectionToken('angularfire2.storage.maxUploadRetryTime');
    /** @type {?} */
    var MAX_OPERATION_RETRY_TIME = new i0.InjectionToken('angularfire2.storage.maxOperationRetryTime');
    /**
     * AngularFireStorage Service
     *
     * This service is the main entry point for this feature module. It provides
     * an API for uploading and downloading binary files from Cloud Storage for
     * Firebase.
     */
    var AngularFireStorage = /** @class */ (function () {
        /**
         * @param {?} options
         * @param {?} nameOrConfig
         * @param {?} storageBucket
         * @param {?} platformId
         * @param {?} zone
         * @param {?} maxUploadRetryTime
         * @param {?} maxOperationRetryTime
         */
        function AngularFireStorage(options, nameOrConfig, storageBucket, 
        // tslint:disable-next-line:ban-types
        platformId, zone, maxUploadRetryTime, maxOperationRetryTime) {
            this.schedulers = new i1.ɵAngularFireSchedulers(zone);
            this.keepUnstableUntilFirst = i1.ɵkeepUnstableUntilFirstFactory(this.schedulers);
            /** @type {?} */
            var app = i1.ɵfirebaseAppFactory(options, zone, nameOrConfig);
            this.storage = i1.ɵfetchInstance(app.name + ".storage." + storageBucket, 'AngularFireStorage', app, ( /**
             * @return {?}
             */function () {
                /** @type {?} */
                var storage = zone.runOutsideAngular(( /**
                 * @return {?}
                 */function () { return app.storage(storageBucket || undefined); }));
                if (maxUploadRetryTime) {
                    storage.setMaxUploadRetryTime(maxUploadRetryTime);
                }
                if (maxOperationRetryTime) {
                    storage.setMaxOperationRetryTime(maxOperationRetryTime);
                }
                return storage;
            }), [maxUploadRetryTime, maxOperationRetryTime]);
        }
        /**
         * @param {?} path
         * @return {?}
         */
        AngularFireStorage.prototype.ref = function (path) {
            return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);
        };
        /**
         * @param {?} path
         * @return {?}
         */
        AngularFireStorage.prototype.refFromURL = function (path) {
            return createStorageRef(this.storage.refFromURL(path), this.schedulers, this.keepUnstableUntilFirst);
        };
        /**
         * @param {?} path
         * @param {?} data
         * @param {?=} metadata
         * @return {?}
         */
        AngularFireStorage.prototype.upload = function (path, data, metadata) {
            /** @type {?} */
            var storageRef = this.storage.ref(path);
            /** @type {?} */
            var ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);
            return ref.put(data, metadata);
        };
        return AngularFireStorage;
    }());
    AngularFireStorage.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'any'
                },] }
    ];
    /** @nocollapse */
    AngularFireStorage.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i1.FIREBASE_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.FIREBASE_APP_NAME,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BUCKET,] }] },
        { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: i0.NgZone },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAX_UPLOAD_RETRY_TIME,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAX_OPERATION_RETRY_TIME,] }] }
    ]; };
    /** @nocollapse */ AngularFireStorage.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFireStorage_Factory() { return new AngularFireStorage(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(BUCKET, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), i0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8)); }, token: AngularFireStorage, providedIn: "any" });
    if (false) {
        /** @type {?} */
        AngularFireStorage.prototype.storage;
        /** @type {?} */
        AngularFireStorage.prototype.keepUnstableUntilFirst;
        /** @type {?} */
        AngularFireStorage.prototype.schedulers;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: pipes/storageUrl.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * to be used with in combination with | async
     */
    var GetDownloadURLPipe = /** @class */ (function () {
        /**
         * @param {?} storage
         * @param {?} cdr
         */
        function GetDownloadURLPipe(storage, cdr) {
            this.storage = storage;
            this.asyncPipe = new common.AsyncPipe(cdr);
        }
        /**
         * @param {?} path
         * @return {?}
         */
        GetDownloadURLPipe.prototype.transform = function (path) {
            if (path !== this.path) {
                this.path = path;
                this.downloadUrl$ = this.storage.ref(path).getDownloadURL();
            }
            return this.asyncPipe.transform(this.downloadUrl$);
        };
        /**
         * @return {?}
         */
        GetDownloadURLPipe.prototype.ngOnDestroy = function () {
            this.asyncPipe.ngOnDestroy();
        };
        return GetDownloadURLPipe;
    }());
    GetDownloadURLPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'getDownloadURL',
                    pure: false,
                },] }
    ];
    /** @nocollapse */
    GetDownloadURLPipe.ctorParameters = function () { return [
        { type: AngularFireStorage },
        { type: i0.ChangeDetectorRef }
    ]; };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        GetDownloadURLPipe.prototype.asyncPipe;
        /**
         * @type {?}
         * @private
         */
        GetDownloadURLPipe.prototype.path;
        /**
         * @type {?}
         * @private
         */
        GetDownloadURLPipe.prototype.downloadUrl$;
        /**
         * @type {?}
         * @private
         */
        GetDownloadURLPipe.prototype.storage;
    }
    var GetDownloadURLPipeModule = /** @class */ (function () {
        function GetDownloadURLPipeModule() {
        }
        return GetDownloadURLPipeModule;
    }());
    GetDownloadURLPipeModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [GetDownloadURLPipe],
                    exports: [GetDownloadURLPipe],
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: storage.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AngularFireStorageModule = /** @class */ (function () {
        function AngularFireStorageModule() {
        }
        return AngularFireStorageModule;
    }());
    AngularFireStorageModule.decorators = [
        { type: i0.NgModule, args: [{
                    exports: [GetDownloadURLPipeModule],
                    providers: [AngularFireStorage]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: public_api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: angular-fire-storage.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.AngularFireStorage = AngularFireStorage;
    exports.AngularFireStorageModule = AngularFireStorageModule;
    exports.BUCKET = BUCKET;
    exports.GetDownloadURLPipe = GetDownloadURLPipe;
    exports.GetDownloadURLPipeModule = GetDownloadURLPipeModule;
    exports.MAX_OPERATION_RETRY_TIME = MAX_OPERATION_RETRY_TIME;
    exports.MAX_UPLOAD_RETRY_TIME = MAX_UPLOAD_RETRY_TIME;
    exports.createStorageRef = createStorageRef;
    exports.createUploadTask = createUploadTask;
    exports.fromTask = fromTask;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-fire-storage.umd.js.map
