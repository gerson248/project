{"version":3,"sources":["../../../src/performance/performance.ts","../../../src/performance/base.ts","../../../src/performance/performance.service.ts","../../../src/performance/performance.module.ts"],"names":["AUTOMATICALLY_TRACE_CORE_NG_METRICS","InjectionToken","INSTRUMENTATION_ENABLED","DATA_COLLECTION_ENABLED","app","instrumentationEnabled","dataCollectionEnabled","zone","platformId","this","performance","of","undefined","pipe","switchMap","isPlatformBrowser","runOutsideAngular","import","EMPTY","map","ɵfetchInstance","shareReplay","bufferSize","refCount","ɵlazySDKProxy","Injectable","args","providedIn","FirebaseApp","Optional","type","Inject","NgZone","Object","decorators","PLATFORM_ID","trace$","traceId","window","entries","getEntriesByName","startMarkName_1","length","endMarkName_1","Observable","emitter","mark","next","unsubscribe","measure","ɵapplyMixins","AngularFirePerformance","trace","IS_STABLE_START_MARK","IS_STABLE_END_MARK","started","PerformanceMonitoringService","appRef","disposable","isStable","first","it","tap","subscribe","prototype","ngOnDestroy","ApplicationRef","perf","_","then","NgModule","providers","name","source$","subscriber","traceSubscription","test","options","a","orComplete"],"mappings":"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","sourcesContent":["import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';\nimport { EMPTY, Observable, of, Subscription } from 'rxjs';\nimport { map, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport firebase from 'firebase/app';\nimport { FirebaseApp, ɵapplyMixins, ɵlazySDKProxy, ɵPromiseProxy } from '@angular/fire';\nimport { isPlatformBrowser } from '@angular/common';\nimport { proxyPolyfillCompat } from './base';\nimport { ɵfetchInstance } from '@angular/fire';\n\n// SEMVER @ v6, drop and move core ng metrics to a service\nexport const AUTOMATICALLY_TRACE_CORE_NG_METRICS = new InjectionToken<boolean>('angularfire2.performance.auto_trace');\nexport const INSTRUMENTATION_ENABLED = new InjectionToken<boolean>('angularfire2.performance.instrumentationEnabled');\nexport const DATA_COLLECTION_ENABLED = new InjectionToken<boolean>('angularfire2.performance.dataCollectionEnabled');\n\nexport interface AngularFirePerformance extends ɵPromiseProxy<firebase.performance.Performance> {\n}\n\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirePerformance {\n\n  private readonly performance: Observable<firebase.performance.Performance>;\n\n  constructor(\n    app: FirebaseApp,\n    @Optional() @Inject(INSTRUMENTATION_ENABLED) instrumentationEnabled: boolean | null,\n    @Optional() @Inject(DATA_COLLECTION_ENABLED) dataCollectionEnabled: boolean | null,\n    private zone: NgZone,\n    // tslint:disable-next-line:ban-types\n    @Inject(PLATFORM_ID) platformId: Object\n  ) {\n\n    this.performance = of(undefined).pipe(\n      switchMap(() => isPlatformBrowser(platformId) ? zone.runOutsideAngular(() => import('firebase/performance')) : EMPTY),\n      map(() => ɵfetchInstance(`performance`, 'AngularFirePerformance', app, () => {\n        const performance = zone.runOutsideAngular(() => app.performance());\n        if (instrumentationEnabled === false) {\n          performance.instrumentationEnabled = false;\n        }\n        if (dataCollectionEnabled === false) {\n          performance.dataCollectionEnabled = false;\n        }\n        return performance;\n      }, [instrumentationEnabled, dataCollectionEnabled])),\n      shareReplay({ bufferSize: 1, refCount: false })\n    );\n\n    return ɵlazySDKProxy(this, this.performance, zone);\n\n  }\n\n}\n\nconst trace$ = (traceId: string) => {\n  if (typeof window !== 'undefined' && window.performance) {\n    const entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n    const startMarkName = `_${traceId}Start[${entries.length}]`;\n    const endMarkName = `_${traceId}End[${entries.length}]`;\n    return new Observable<void>(emitter => {\n      window.performance.mark(startMarkName);\n      emitter.next();\n      return {\n        unsubscribe: () => {\n          window.performance.mark(endMarkName);\n          window.performance.measure(traceId, startMarkName, endMarkName);\n        }\n      };\n    });\n  } else {\n    return EMPTY;\n  }\n};\n\nexport const traceUntil = <T = any>(\n  name: string,\n  test: (a: T) => boolean,\n  options?: { orComplete?: boolean }\n) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(\n    tap(\n      a => test(a) && traceSubscription.unsubscribe(),\n      () => {\n      },\n      () => options && options.orComplete && traceSubscription.unsubscribe()\n    )\n  ).subscribe(subscriber);\n});\n\nexport const traceWhile = <T = any>(\n  name: string,\n  test: (a: T) => boolean,\n  options?: { orComplete?: boolean }\n) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n  let traceSubscription: Subscription | undefined;\n  return source$.pipe(\n    tap(\n      a => {\n        if (test(a)) {\n          traceSubscription = traceSubscription || trace$(name).subscribe();\n        } else {\n          if (traceSubscription) {\n            traceSubscription.unsubscribe();\n          }\n\n          traceSubscription = undefined;\n        }\n      },\n      () => {\n      },\n      () => options && options.orComplete && traceSubscription && traceSubscription.unsubscribe()\n    )\n  ).subscribe(subscriber);\n});\n\nexport const traceUntilComplete = <T = any>(name: string) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(\n    tap(\n      () => {\n      },\n      () => {\n      },\n      () => traceSubscription.unsubscribe()\n    )\n  ).subscribe(subscriber);\n});\n\nexport const traceUntilFirst = <T = any>(name: string) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(\n    tap(\n      () => traceSubscription.unsubscribe(),\n      () => {\n      },\n      () => {\n      }\n    )\n  ).subscribe(subscriber);\n});\n\nexport const trace = <T = any>(name: string) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(\n    tap(\n      () => traceSubscription.unsubscribe(),\n      () => {\n      },\n      () => traceSubscription.unsubscribe()\n    )\n  ).subscribe(subscriber);\n});\n\nɵapplyMixins(AngularFirePerformance, [proxyPolyfillCompat]);\n","export const proxyPolyfillCompat = {\n  trace: null,\n  instrumentationEnabled: null,\n  dataCollectionEnabled: null,\n};\n","import { ApplicationRef, Injectable, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { first, tap } from 'rxjs/operators';\n\nconst IS_STABLE_START_MARK = '_isStableStart';\nconst IS_STABLE_END_MARK = '_isStableEnd';\n\nfunction markStarts() {\n    if (typeof(window) !== 'undefined' && window.performance) {\n        window.performance.mark(IS_STABLE_START_MARK);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nconst started = markStarts();\n\n@Injectable()\nexport class PerformanceMonitoringService implements OnDestroy {\n\n    private disposable: Subscription|undefined;\n\n    constructor(appRef: ApplicationRef) {\n        if (started) {\n            this.disposable = appRef.isStable.pipe(\n                first(it => it),\n                tap(() => {\n                    window.performance.mark(IS_STABLE_END_MARK);\n                    window.performance.measure('isStable', IS_STABLE_START_MARK, IS_STABLE_END_MARK);\n                })\n            ).subscribe();\n        }\n    }\n\n    ngOnDestroy() {\n        if (this.disposable) { this.disposable.unsubscribe(); }\n    }\n\n}\n","import { NgModule, Optional } from '@angular/core';\nimport { AngularFirePerformance } from './performance';\nimport { PerformanceMonitoringService } from './performance.service';\n\n@NgModule({\n  providers: [ AngularFirePerformance ]\n})\nexport class AngularFirePerformanceModule {\n  constructor(\n    perf: AngularFirePerformance,\n    @Optional() _: PerformanceMonitoringService\n  ) {\n    // call anything here to get perf loading\n    // tslint:disable-next-line:no-unused-expression\n    perf.dataCollectionEnabled.then(() => {});\n  }\n}\n"]}